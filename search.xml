<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>百度之星内训班竞赛题</title>
      <link href="/post/6673.html"/>
      <url>/post/6673.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="题目一-神奇排列"><a href="#题目一-神奇排列" class="headerlink" title="题目一 神奇排列"></a>题目一 神奇排列</h2><p>给定正整数n，求一个长度为2n的数组，满足：<br>1 数组由 1 ~ 2n 共2n个数字打乱组成，且每个数字出现一次<br>2 每个偶数位（从0开始）和其右边的数字（奇数位上）的和组成的长度为n的新数组是一个公差为1的等差数列</p><p>输入：</p><ul><li>第一行一个数字，test的次数</li><li>后面test行，每一行一个数字，为当前test的n<br>输出：</li><li>如果不能组成这样的2n长度数组，输出NO</li><li>如果可以，输出YES，并且打印数组</li></ul><p>样例：<p></p><blockquote><p>输入：</p></blockquote><ul><li>4<p>1<p>2<p>3<p>5<p></li></ul><blockquote><p>输出:</p></blockquote><ul><li>YES<p>2 1<p> NO <p>YES<p> 4 2 6 1 5 3 <p>YES <p>6 3 8 2 10 1 7 5 9 4</li></ul><p>这其实是一个技巧题。如果观察和稍加推导就发现：<br>1 偶数是一定会输出NO。因为中间的和会是一个.5的小数，整数凑不出来<br>2 所有的奇数，在前一半数组中奇数位的数字是n+1，后一半是n+2。我尝试证明，但是感觉有点点复杂。<br>3 既然这样，我们就写出来，在再验证看看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printarray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">2</span> * n + <span class="number">1</span> - (n &gt;&gt; <span class="number">1</span>) + j - i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">2</span>, j = <span class="number">0</span>; j &lt; (n &gt;&gt; <span class="number">1</span>); i += <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">2</span> * n + <span class="number">2</span> + j - i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> test = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; test;</span><br><span class="line">    <span class="keyword">while</span> (test--) &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printarray</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>输入 1 5 输出 6 3 8 2 10 1 7 5 9 4</code></p></li><li><p><code>输入 1 7 输出 8 4 10 3 12 2 14 1 9 7 11 6 13 5</code><br>看起来没毛病，我们再用对数器试一下</p></li></ul><div class='spoiler collapsed'>    <div class='spoiler-title'>        对数器版    </div>    <div class='spoiler-content'>        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">printarray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// int * originalarray = new int[2*n];</span></span><br><span class="line">    <span class="type">int</span>* processedarray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>*n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>*n; i++) &#123;</span><br><span class="line">        processedarray[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n; i += <span class="number">2</span>, j++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">2</span> * n + <span class="number">1</span> - (n &gt;&gt; <span class="number">1</span>) + j - i;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; tmp &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        processedarray[i] = processedarray[tmp] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">2</span>, j = <span class="number">0</span>; j &lt; (n &gt;&gt; <span class="number">1</span>); i += <span class="number">2</span>, j++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">2</span> * n + <span class="number">2</span> + j - i;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; tmp &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        processedarray[i] = processedarray[tmp] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processedarray[i] != <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Oops!&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; is bad!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">                cout&lt;&lt;processedarray[i];            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] processedarray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">delete</span>[] processedarray;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="comment">// delete[] originalarray;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> test = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> continue1 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (test--&amp;&amp;continue1)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            continue1 = <span class="built_in">printarray</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        n += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    </div></div><p>用暴力方法来gank，验证从1到2n，每一个数字是不是出现了，程序结果输出20001，意味着前n &#x3D; 1~10000都是正确的，基本上是可以确定没毛病了。</p><h2 id="题目二-浇水"><a href="#题目二-浇水" class="headerlink" title="题目二 浇水"></a>题目二 浇水</h2><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SAF会议_2023_08_03</title>
      <link href="/post/1e40.html"/>
      <url>/post/1e40.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="好处？"><a href="#好处？" class="headerlink" title="好处？"></a>好处？</h2><p><br>1 英语能力，口语听力阅读，大量 paper work<br><br>2 海外名校官方学分+成绩单（至少B+），实质性证明<br><br>3 推荐信（有机会，博士），本科生、名校研究生：海外名校本科老师的推荐信就够了(强推更好)<br><br>4 自信、人脉</p><h2 id="加州"><a href="#加州" class="headerlink" title="加州"></a>加州</h2><p>大学系统，不是分校。互相认可。</p><h2 id="加州大学洛杉矶分校-寒假大数据"><a href="#加州大学洛杉矶分校-寒假大数据" class="headerlink" title="加州大学洛杉矶分校-寒假大数据"></a>加州大学洛杉矶分校-寒假大数据</h2><img src="/post/1e40/page1.png" class="" title="洛杉矶分校大数据1"><br><img src="/post/1e40/page2.png" class="" title="洛杉矶分校大数据2"><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络第一章—体系结构笔记(未完)</title>
      <link href="/post/b13a.html"/>
      <url>/post/b13a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="计算机网络的概述"><a href="#计算机网络的概述" class="headerlink" title="计算机网络的概述"></a>计算机网络的概述</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>计网是将独立功能的计算机系统通过通信设备与线路、软件、协议，实现资源共享和信息传递。<br>互连（通过通信链路互联互通）、自治（无主从关系）的计算机集合。</p><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>第一阶段：分散系统？ARPAnet，同一类型网络；不同网络互联？internet（TCP&#x2F;IP协议）-&gt;Internet（全世界最大的计算机网络）<br>节点+路由器 &#x3D; 网络； 网络*n &#x3D; 互联网<br>第二阶段：NSF+6大型计算机中心 &#x3D; 三级结构。校园网、企业网-&gt;地区网-&gt;主干网<br>第三阶段：多层次ISP结构（因特网服务提供）主干、地区、本地，网络管理权分散。网费：ISP服务费。因特网管理机构管理IP池。本地-&gt;地区-&gt;主干-&gt;地区-&gt;本地；本地-&gt;地区-&gt;IXP(因特网交换点)-&gt;地区-&gt;本地</p><h3 id="不同视角下的组成方式"><a href="#不同视角下的组成方式" class="headerlink" title="不同视角下的组成方式"></a>不同视角下的组成方式</h3><ul><li><h4 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h4><code>硬件、软件、协议</code></li><li><h4 id="整体组成–工作方式"><a href="#整体组成–工作方式" class="headerlink" title="整体组成–工作方式"></a>整体组成–工作方式</h4><code>边缘部分（接入的计算机，用户端）</code>  + <code>核心部分（提供服务）</code></li></ul><br>***边缘部分通信方式*** <br>  <p>端到端通信：进程（软件如QQ）之间的通信。两大模式<br>> C/S vs B/S: - C/S（Client & Server）常用，服务与被服务，如QQ- B/S（Browser & Server）> P2P- (peer to peer)设备间无固定身份，同时是客户和服务器，”我为人人人人为我“;<br><ul><li><h4 id="功能组成——实现数据通信和资源共享"><a href="#功能组成——实现数据通信和资源共享" class="headerlink" title="功能组成——实现数据通信和资源共享"></a>功能组成——实现数据通信和资源共享</h4></li></ul><p>数据通信：通信子网，包括：#3 <code>网络层</code>（路由器），#2 <code>数据链路层</code>（交换机，网桥），#1 <code>物理层</code>（集线器，中继器）。由传输介质、通信设备、相应协议组成。<br>中间：#4 <code>传输层</code>。<br>资源共享：资源子网，包括： #5 <code>会话层</code>，#6 <code>表示层</code>，#7 <code>应用层</code>。由相应软件和设备组成。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li><code>数据通信</code>（数据）</li><li><code>资源共享</code>（数据+硬件+软件）（如何处理请求？操作系统。）</li><li><code>分布式处理</code>（承担同意工作任务的不同部分，Hadoop）<ul><li>（-&gt;<code>提高可靠性</code>，<code>负载均衡</code>），</li></ul></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>范围:</li></ul><p><code>广域网(交换技术)</code> <code>城域网</code><br><code>局域网(-&gt;)广播技术)</code> <code>个人区域网</code></p><ul><li>使用者:<br>公用网（平民） 专用网（政府军队）   </li><li>交换技术:</li></ul><p><code>电路交换（占用资源+释放资源）</code> <code>报文交换/分组交换(存储转发)</code></p><ul><li>拓扑结构:<br>总线型，星形，环形，网状型</li><li>传输技术:<br>广播式（所有用户都知道）， 点对点网络（分组存储转发和路由选择机制）</li></ul><p>看到这里，来一张图片总结一下：</p><img src="/post/b13a/wangluocover1.png" class="" title="概述脑图"><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="速率专题"><a href="#速率专题" class="headerlink" title="速率专题"></a>速率专题</h3><p><code>带宽</code>：一般指某一链路上（两个点之间）支持的的“最高数据率”（即理想状态下的能力），单位：b&#x2F;s, kb&#x2F;s, Mb&#x2F;s, Gb&#x2F;s, Tb&#x2F;s  相邻10^3)<br><code>传播速率</code>：2.0E+8 m&#x2F;s<br><code>传输速率</code>：连接在网络上的<code>某一主机</code>在信道上传送数据位数的速率。也称数据率&#x2F;数据传输率&#x2F;比特率(传输数据位数的速率：b&#x2F;s, kb&#x2F;s, Mb&#x2F;s, Gb&#x2F;s, Tb&#x2F;s  相邻10^3)(理论值)<br><code>注意：存储容量数据位数的单位：B, kB, MB, GB, TB  相邻2^10, 1 Byte = 8 bit</code><br>吞吐量：单位时间通过<code>某个网络上（网卡）</code>或者<code>信道</code>或者<code>接口</code>的数据量(多对多)，受到<code>额定传输速率</code>和<code>带宽</code>的限制。</p><p><em><strong>发送的速率和接口关系比较大，而接受速率被缓存、线路质量等限制</strong></em><br>鉴于这三者的关系过于暧昧，我请教了gpt来答疑解惑：</p><ul><li>gpt解释之文字版</li></ul><blockquote><p>直接看结论：</p></blockquote><p>我们可以将这三个概念简单地理解为：<br><br><code>带宽：对信道能力的衡量，是理论上的最大数据传输能力。</code><br><code>吞吐量：在实际操作中，能够通过网络或信道成功传输的数据量。这是一个实际的测量值，通常受到网络状况（如延迟、数据丢失和重传等）的影响，所以吞吐量通常会小于带宽。</code><br><code>传输速率：针对特定的主机或设备，其在网络中发送数据的理论能力。</code></p><blockquote><p>我时间多，想看具体解释</p></blockquote><p>带宽：通常指的是 <em><strong>.<code>通信信道</code>的数据传输能力</strong></em>也就是单位时间内传送的数据量。比如，我们经常会听到10Mbps，100Mbps，1Gbps等说法，这些都是带宽的描述。带宽越大，<code>理论</code>上单位时间内可以传送的数据量就越大。然而，实际的数据传输量往往受到很多因素的影响，比如网络拥堵，数据丢失和重传等，因此实际的数据传输量通常会小于带宽。</p><p>吞吐量：吞吐量是指单位时间内成功传送的数据量。与带宽不同，吞吐量是一个实际的测量值，反映的是实际的数据传输效果，是对整个网络或者特定信道、接口的实际传输效果的度量。吞吐量受到许多因素的影响，比如带宽，网络延迟，数据丢失和重传等。<em><strong>你的网络吞吐量就是你<code>实际</code>下载文件的速度。</strong></em></p><p>传输速率：传输速率是指一个特定的主机或设备，单位时间内发送的比特数。与带宽相似，传输速率也是一个<code>理论值</code>。在实际应用中，由于需要对数据进行编码，添加错误检测和纠正码，以及其他协议开销，实际的数据传输速率通常会小于物理传输速率。通常情况下，我们所说的网络速度，比如10Mbps，100Mbps等，实际上是指的物理传输速率。实际的传输速率可能会受到许多因素的影响，比如网络拥塞，接口性能，发送数据的类型和大小。<em><strong>传输速率是针对单一主机或设备的特性，而不是整个网络或者信道的性能。</strong></em></p><blockquote><p>gpt解释之表格版</p></blockquote><img src="/post/b13a/image_2023-08-04_01-14-35.png" class="" title="gpt表格版"><h3 id="时延-延迟-迟延"><a href="#时延-延迟-迟延" class="headerlink" title="时延&#x2F;延迟&#x2F;迟延"></a>时延&#x2F;延迟&#x2F;迟延</h3><p>指数据从出发到目的地所需要的时间（单位：s）。<br>按先后顺序分为：<code>发送时延</code>，<code>传播时延</code>，<code>排队时延</code>，<code>处理时延</code></p><ul><li>发送时延(bit&#x2F;s)<br><code>主机接口</code>处用于<code>输出数据</code>所用总时间。公式：（数据长度）&#x2F;（信道带宽&#x2F;发送时率）。带宽对这的影响最大，常说的高速链路就是指发送时延低。</li><li>传播时延(m&#x2F;s)<br>路途中传输数据用时。公式：（信道长度）&#x2F;（电磁波传播数率）</li><li>排队时延<br>从 <code>数据到达目的地</code> 开始到 <code>数据被处理</code> 用时。即等待链路可用。</li><li>处理时延<br>检错、找出口用时。<img src="/post/b13a/shiyanwangdao.png" class="" title="时延"></li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>formula : 时延带宽积 &#x3D; 传播时延 * 带宽<br>bit &#x3D; s * (b&#x2F;s)<br>指：假设某主机不间断向服务器发送数据，第一个比特到达服务器时，整个信道上的比特数。亦即：信道满载时的比特数。亦即：以比特为单位的链路长度。</p><p>这是csdn一个博主的解释：</p><img src="/post/b13a/delaycsdn1.png" class="" title="时延带宽积"><p><br>原链接：</p><blockquote><p><a href="https://blog.csdn.net/ahLOG/article/details/116202211" target="_blank">延时带宽积</a></p></blockquote><h3 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h3><p>从发送的第一个bit开始计时，到服务器针对所接收数据而返回的信息到达发送方为止。<br>formula: 传播时延*2+末端处理时间<br>注意：跟传输时间没有半毛钱关系！<br>推导：RTT越大，在收到确认之前，可以发送的数据越多。</p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>信道利用率：有数据在信道上的时间&#x2F;总时间<br>网络利用率：信道利用率的加权平均值<br>与时延的近似关系：时延 &#x3D; -1&#x2F;(利用率-1)</p><img src="/post/b13a/guanxi.png" class="" title="时延"><h2 id="体系结构-参考模型"><a href="#体系结构-参考模型" class="headerlink" title="体系结构&amp;参考模型"></a>体系结构&amp;参考模型</h2><blockquote><p>计算机网络体系结构简称网络体系结构，是分层结构，是各层及其协议的集合</p></blockquote><h3 id="分层结构-协议-接口-服务"><a href="#分层结构-协议-接口-服务" class="headerlink" title="分层结构&#x2F;协议&#x2F;接口&#x2F;服务"></a>分层结构&#x2F;协议&#x2F;接口&#x2F;服务</h3><ul><li><h4 id="分层结构-实体"><a href="#分层结构-实体" class="headerlink" title="分层结构&#x2F;实体"></a>分层结构&#x2F;实体</h4>1 各层相互独立     <p>   2 每层之间交流尽可能少  <p> 3 促进标准化，每层用最合适的技术  <p>   4 层数相等的才称为<code>对等实体</code>，共用一套协议</li><li><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4>1 水平方向，对等实体 2 语法、语义、同步（顺序）的互通</li><li><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4>1 垂直方向 2 下层为上层提供服务，给上层提供服务所需要的<code>接口</code></li><li><h4 id="数据单元"><a href="#数据单元" class="headerlink" title="数据单元"></a>数据单元</h4>1 SDU-&gt;Service Data Unit， 服务数据单元，“原始数据”<br>2 PCI-&gt;Protocol Control Information，协议控制信息用于保持同步，例如序列号，校验和，帧类型。<br>3 PDU-&gt;Protocol Data Unit，协议数据单元，PDU &#x3D; PCI+SDU。</li><li>服务和接口不能跨层<blockquote><p>广义上，SDU，PCI，PDU可以指任何一层对应的数据</p></blockquote></li></ul><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>OSI参考模型 + TCP&#x2F;IP参考模型 &#x3D; 5层体系结构</p><h2 id="OSI参考模型（7层）"><a href="#OSI参考模型（7层）" class="headerlink" title="OSI参考模型（7层）"></a>OSI参考模型（7层）</h2><p>法定标准，IBM公司的SNA是第一个网络体系结构，后来又DEC的DNA，美国国防部的TCP&#x2F;IP。<br>ISO公司1984提供OSI模型，非垄断，支持异构网络系统的互联互通。理论成功，市场失败。</p><img src="/post/b13a/seven_level_structure.png" class="" title="七层结构：“物联网淑慧试用”"><img src="/post/b13a/4vs3.png" class="" title="上四层体现为端到端，下三层体现为点到点"><img src="/post/b13a/full_process.png" class="" title="数据链路层才有头尾，物理层传0和1"><ul><li><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4></li></ul><p>程序本身   </p><ul><li><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4></li></ul><p>1 格式变换 <p> 2 加密解密 <p> 3 压缩恢复</p><ul><li><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4></li></ul><p>向表示层&#x2F;用户进程建立连接<p><br>1 建立、管理、终止会话 <p> 2 使用校验点&#x2F;同步点恢复通信，实现同步(传输大文件)</p><ul><li><h4 id="传输层（传输单位：报文段-用户数据报）"><a href="#传输层（传输单位：报文段-用户数据报）" class="headerlink" title="传输层（传输单位：报文段&#x2F;用户数据报）"></a>传输层（传输单位：报文段&#x2F;用户数据报）</h4></li></ul><p>1 可靠传输（大文件，需要校验）&#x2F;不可靠传输（小文件）<p><br>2 差错控制<p><br>3 流量控制（防止缓存过多）<p><br>4 复用（多个应用层同时使用下面的运输层服务）分用（运输层把信息分别交给对应进程）</p><ul><li><h4 id="网络层-数据报-n-分组，分开方便传输"><a href="#网络层-数据报-n-分组，分开方便传输" class="headerlink" title="网络层(数据报 &#x3D; n * 分组，分开方便传输)"></a>网络层(数据报 &#x3D; n * 分组，分开方便传输)</h4></li></ul><p>1 路由选择-&gt;最佳路径<p><br>2 差错控制<p><br>3 流量控制<p><br>4 拥塞控制</p><ul><li><h4 id="数据链路层-帧-n-数据报"><a href="#数据链路层-帧-n-数据报" class="headerlink" title="数据链路层 帧 = n * 数据报"></a>数据链路层 <code>帧 = n * 数据报</code></h4></li></ul><p>1 成帧 <p>2 差错控制<p> 3 流量控制 <p>4 访问接入控制（广播式，控制信道访问） </p><ul><li><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4></li></ul><p>1 定义解口特性  <p>2 单工（固定角色）；半双工（同时只有一个人发送信息，但是都有机会发送、接收）；双工（同时发送、接收） <p>3 定义传输速率 <p> 4 比特同步（时钟控制） <p> 5 比特编码（电压范围） </p><h2 id="TCP-IP参考模型（4层）"><a href="#TCP-IP参考模型（4层）" class="headerlink" title="TCP&#x2F;IP参考模型（4层）"></a>TCP&#x2F;IP参考模型（4层）</h2><p>事实标准（先有协议才有模型）</p><img src="/post/b13a/ISO_vs_TCP_IP.png" class="" title="对比"><img src="/post/b13a/ISO_vs_TCP_IP(2).png" class="" title="对比(2)"><p>为什么说TCP&#x2F;IP将IP作为重要层次，所以在网络层指由无连接的模式？</p><details>  <summary>ChatGPT的回答</summary>TCP/IP是一种通信协议族，由两个主要的协议组成：TCP（传输控制协议）和IP（网际协议）。它们在计算机网络中扮演了重要的角色。<br>TCP/IP将IP作为重要的层次，因为IP负责在网络层提供数据包的路由和传递。网络层是TCP/IP协议栈中的第三层，其主要功能是处理数据包的转发和路由，以确保数据能够在不同网络之间传输。<br>IP协议采用无连接的传输模式，也称为"无状态"传输。这意味着在传输数据之前，IP不会建立任何持久的连接或会话状态。每个数据包在传输时都是独立的实体，它们被独立地处理和转发，与之前或之后的数据包没有直接关联。<br>IP作为无连接协议的主要优点是简单和灵活。由于每个数据包都是独立的，网络中的路由器可以更容易地处理和转发它们。这种无连接的特性使得IP协议适用于许多不同类型的网络，并且使得网络扩展更加容易，因为新的设备可以很容易地加入网络而不需要修改网络的整体结构。<br>然而，无连接的传输模式也带来了一些问题。由于IP不维护连接状态，因此无法保证数据包的顺序到达目的地，也不能保证数据包的可靠传输。为了解决这些问题，TCP协议在IP之上提供了可靠的、面向连接的数据传输，从而构成了TCP/IP协议栈的两个主要部分。<br>总的来说，TCP/IP将IP作为重要的层次，并在网络层采用无连接的传输模式，这使得网络可以更加灵活和简单，但也需要上层协议如TCP来提供可靠性和有序性。</details><h3 id="5层结构"><a href="#5层结构" class="headerlink" title="5层结构"></a>5层结构</h3><img src="/post/b13a/5%E5%B1%82%E7%BB%93%E6%9E%84.png" class="" title="结构"><img src="/post/b13a/5%E5%B1%82%E8%A7%A3%E5%B0%81%E8%A3%85.png" class="" title="步骤"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/post/b13a/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%84%91%E5%9B%BE%E6%80%BB%E7%BB%93.png" class="" title="summary"><p>第一章用了两天时间刷完了，感觉有点喘不上气，不过情绪还算平稳。用这个速度下去岂不是特么半个月学完了。。。所以还是要刷题巩固，要不然全是骗自己呢。加油😄。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大一暑假小结</title>
      <link href="/post/97185e65.html"/>
      <url>/post/97185e65.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="暑假过半小总结"><a href="#暑假过半小总结" class="headerlink" title="暑假过半小总结"></a>暑假过半小总结</h1><h2 id="学习永无止境"><a href="#学习永无止境" class="headerlink" title="学习永无止境"></a>学习永无止境</h2><p>自从放假以来，已经有一个多月了。这三十多天里，虽然不能说收获颇多，起码能称得上充实有料。都快上大二的人了，才开始重视保研竞赛加分，只能说侧面反映这个大一摆得真得舒服。不论怎样，起码已经开始动起来了：</p><h3 id="算法：从入门到入士"><a href="#算法：从入门到入士" class="headerlink" title="算法：从入门到入士(?"></a>算法：从入门到入士(?</h3><p>学习了（观看，部分实现）左神的19节体系算法班的课程，课程时长共计40h，接触了包括但不限于复杂度、异或运算、归并排序、二叉树、递归与动态规划、KMP算法、bfprt算法等等知识概念，不过有很大程度<br>上都是看得很爽而自己不太想动手。这是一个需要耐心解决的毛病😄。主要还是要亲自下海感受一下这些算法的魅力之处，老是看别人玩怎么行，不手撕一下代码这个东西永远都是别人的。所以，从今天起，每一次的课程都要<br>以自己动手为最终目标，而不是以量为目标学习。不过量也不能太少，起码每天要接触些新的奇技淫巧，也要做到手不生疏就行。</p><h3 id="规划：任何时候都不迟！"><a href="#规划：任何时候都不迟！" class="headerlink" title="规划：任何时候都不迟！"></a>规划：任何时候都不迟！</h3><p>初步了解、规划大二的时间安排情况。<code>首先</code>要保证课内的课程分数可观，起码要能有一定的提升，主课不能落下，所以晚上千万要早一些睡。 <code>其次</code>，要及时关注教务处的通知，比如这一次的全国大学生数学竞赛就是因为我太专注于<br>（？还不是你好久没登教务处网）复习而没有关注到报名需求，导致最后失去这个绝佳的机会。又要等待一年才能有机会参加。 <code>最后</code>，要合理规划时间，腾出来的时间要么用来看专业书，要么用来看名校的网课，要么用来考研，要么用来提高课内的学分绩点课程，要么用来弄竞赛或者科研，要么用来跑实验室给学长学姐打杂活（如果有机会进实验室的话🤭）。总之，用来玩的时间可以说越来越少了，大学很短，且行且珍惜。</p><h3 id="走访：穿越到未来看我的样子"><a href="#走访：穿越到未来看我的样子" class="headerlink" title="走访：穿越到未来看我的样子"></a>走访：穿越到未来看我的样子</h3><p>这个暑假还<code>走访了oppo、百度、腾讯三家头部企业</code>，其中oppo是我校的学长学姐接待的，热情满满；百度是部门刚入职的学长接待的，很接地气；腾讯是位十分漂亮的小姐姐带我们走了全程，传授了很多面经。总的来说，虽然我还没有接触什么技术栈或者一些具体的工作流程，但是在像这些公司一样的一家<code>重视员工</code>的企业，我觉得<code>非常具有幸福感</code>~跟他们交流，不仅对自己的未来规划会更加清晰，还能收获一些分量十足的建议，这也是我非常想进实验室的原因。一定要努力呀！！</p><h3 id="自我反思：提醒自己入行的初衷"><a href="#自我反思：提醒自己入行的初衷" class="headerlink" title="自我反思：提醒自己入行的初衷"></a>自我反思：提醒自己入行的初衷</h3><p>其实我还是会时常问自己，为什么我要选择这个道路？思来想去，到最后答案都是想创造一个机器替代人工的社会，一个生产力爆棚的社会，一个精神层次能更高的社会。我小时候就有<code>危机感</code>，害怕人类被机器取代以后就难以掌控世界。其实这种担心客观来说是合理的，但是这不是抑制技术发展的理由。我相信在良好的环境（不论是监管环境，开源环境或者是某些方面的社会环境）下，机器一定能给人一种<code>类天堂</code>的感觉，只是这离我们还有一点点距离。在这个注定会深刻改变未来的时间点，踏足计算机科学真的是一件很酷的事情。</p><h2 id="给生活加点料"><a href="#给生活加点料" class="headerlink" title="给生活加点料"></a>给生活加点料</h2><h3 id="足球：最大的爱好"><a href="#足球：最大的爱好" class="headerlink" title="足球：最大的爱好"></a>足球：最大的爱好</h3><p>一回来就有同学约球，一踢就是到晚上十点，结果回家的路上去地铁站，跟同学聊天tmd走偏了好几公里，好在赶上末班车顺利到家😕，要不真的半夜还在马路上，谁看了都担心这帅小伙被拐走了U•ェ•*U</p><h3 id="电影：八角笼中"><a href="#电影：八角笼中" class="headerlink" title="电影：八角笼中"></a>电影：八角笼中</h3><p>高中同学约我去看，虽然套路确实太tm土了，不过里面的一些人物还是挺引人深思的：穷困家庭的孩子，小时候就跟着大人一起打劫，就算是后来被培养成了拳击能手，<code>一旦失去了一个长辈的在场管教</code>，他就像一块永磁铁，被打劫这一块吸铁石牢牢地吸走，重新开启旧事业。老鼠儿子会打洞，<code>人的家庭环境对其一生的影响是不可估量的</code>。你说这个拳击教练他有错吗？<code>必然有</code>，因为他插手了这些孩子们的童年和青春，所以他必须要为他们的成人做好准备。既然他是唯一一个孩子们亲近的大人，除了教他们打假赛挣钱（不寒掺！），更要给他们一些<code>心理的建设</code>，这才是支撑他们克服原生家庭的<code>唯一法宝</code>。他们重拾旧业，就是因为他们骨子里还是那个穷小子，那个没有一技傍身的“屌丝”、“愣头青”，即使他们已经在拳击行业有一些傲人的成就。我记得到最后他们也没有真正进学校上过一次学，意味着他们的学历将是“无”，虽然我也不搞学历崇拜，但是现实中如果有这么一批孩子，是多么可悲、可怜。所以，其实这整个社会都付有一定的连带责任，但是如果这个社会并不是唯学历论，我相信这群年轻的孩子肯定可以通过自己的双手打拼出来，<code>带着他们的姐姐来城市看一看世间的繁华</code>，而不是窝在阴暗的床上编手工品。</p><h3 id="探访母校：对人以诚，对事以精"><a href="#探访母校：对人以诚，对事以精" class="headerlink" title="探访母校：对人以诚，对事以精"></a>探访母校：对人以诚，对事以精</h3><p>看完电影，同学说想参观下我的初中母校，于是步行10min到达校门口。跟警卫处说明来意，他们非常乐意地开了门。我们绕了整个学校一圈，还特地去九六班看了看，怀念那时的卷王姿态啊~中午放学、下午放学我总是全班最后一个走，真想不懂那时为啥这么卷，也许就是那时的我给我现在的条件吧。应了多年前的那句网络名言“未来的你，会感谢现在努力的自己”。实话实说，在城市中心夜晚的母校，就是望着窗外睡一觉都会感觉很舒服。我可能是个灯光控吧😄。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这个暑假还有一些小故事，比如，pubg<code>出了金</code>（烟枪，虽然没啥用，不过这是第二次免费出金了嘻嘻）；还有<code>分到了想去的人工智能专业</code>等等，不一而足。一句话概括，那就是：<br><code>这个暑假，就像一把鲜艳的画笔，每一滴墨水都深深地烙印在我人生的画卷上，为我这平淡无奇的学生生涯添上了丰富的色彩，纵使未来充满挑战，但我一定能看到希望，把握机遇。</code></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日记/规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 活着，就要有人样 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序之反思</title>
      <link href="/post/673e5681.html"/>
      <url>/post/673e5681.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>  众所周知，快速排序是一个复杂度较为低的排序，平均时间复杂度约n*log(n)，今天，我尝试对快速排序的本质做一些理解和复习。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pointer1 = left, pointer2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> s = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>* help2 = <span class="keyword">new</span> <span class="type">int</span>[s];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pointer1 &lt;= mid &amp;&amp; pointer2 &lt;= right) &#123;</span><br><span class="line">        help2[i++] = a[pointer1] &lt; a[pointer2] ? a[pointer1++] : a[pointer2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pointer1 &lt;= mid) &#123;</span><br><span class="line">        help2[i++] = a[pointer1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pointer2 &lt;= right) &#123;</span><br><span class="line">        help2[i++] = a[pointer2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        a[left + i] = help2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] help2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这是一开始的想法。取最左边的元素为<code>基准点</code>，然后j先动，直到找到<code>小于基准点</code>的那个元素；接着动i，直到找到<code>大于基准点</code>的那个元素；交换j,i的元素；像这个步骤顺序执行，直到任何一刻，<code>i == j</code>，然后，<br>交换i位置和<code>基准点</code>位置的元素。这样就能达到<code>基准点</code>左侧的数<code>小于基准点</code>，<code>基准点</code>左侧的数<code>大于基准点</code>。然后，再调用递归，分别将<code>基准点</code>左侧和右侧<code>修正</code>为面向<code>新基准点</code>的类排序<br>状态，直到这个调用结束。说实话，这有一点像深度优先搜索的例子。<br>    但是，chatgpt告诉我，它有更好的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left];</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[i++] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[j--] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    <span class="built_in">quicksort</span>(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quicksort</span>(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这是gpt的思路：它一开始就不打算将arr[left]保留至原位置。当j移动到<code>小于基准点</code>的位置，原来i位置的数会被j位置的覆盖；然后i移动到<code>大于基准点</code>的位置，j位置的数于是被i位置的覆盖。如此循环，仅仅a[left]是没有<br>被放进数列的。最后当i和j相遇，不管前面是什么情况，这个相遇位置的数一定已经被移动到它应该去的地方，于是在此处写入a[left]。然后也是调用递归。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>   其实快速排序让我敬畏之许久，导致很长一段时间我都觉得这个排序很“迷”。为何？因为它的边界条件、特殊情况和执行顺序：</p><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p>   a[left]是最大的数，且整个数列是逆序的，不就会执行非常多次？<br>    确实，如果是逆序，那么是会执行n + (n-1) + (n-2) + … + 1 次，也就是冒泡排序的次数。</p><h3 id="特殊情况-执行顺序"><a href="#特殊情况-执行顺序" class="headerlink" title="特殊情况&#x2F;执行顺序"></a>特殊情况&#x2F;执行顺序</h3><p>   如果i从左至右能找到三个<code>大于基准点</code>的数，反之j从右至左能找到一个或者两个<code>小于基准点</code>的数，那么这个排序不就不成立了？这是我从一开始就很疑惑的点。不妨来举一个例子说清楚这个问题：<br><code>arr = &#123;5, 6, 7, 8, 2 , 1&#125;</code>这个数组执行代码（第一种解法）过程中，1 和 6 会被先定位，然后交换<code>arr = &#123;5, 1, 7, 8, 2 , 6&#125;</code>，接着是2，7，<code>arr = &#123;5, 1, 2, 8, 7, 6&#125;</code></p><p>接下来，就是这个排序的精华（起码我是这么认为的啦）了：永远先让j动——j移动到 “2” 的位置，与i重合。然后 5 和 2 交换，得到<code>arr = &#123;2, 1, 5, 8, 7, 6&#125;</code>，怎么样，不还是能跑嘛！</p><p>   <em><strong>其实，j 先动，就能保证j右边的全是比 j 要大的，这是最重要的一环。</strong></em></p><p>如果把 i 和 j 的移动顺序调换，上面的例子会变成<code>arr = &#123;8, 1, 2, 5, 7, 6&#125;</code>（ i 先到 8 的位置）。这样就不符合 5 左边的数都比 5 小的初衷了。因为，如果 i 先动，只能保证 i 左边的数会比 <code>基准点</code> 小，但是这个过程中一旦 i 和 j 碰面了，或者像这个例子，i右边且j左边没有小于<code>基准点</code>的数了，一定会让这个尴尬的位置非常棘手。<em><strong>究其根本的原因，<br>   就是我们规定的是左小右大的排列顺序：最后一个和a[left]交换的一定不能大于<code>基准点</code>。所以，当j先动，不可避免地遇上了i，此时的i是先前被交换过来的那个 <code>旧j</code>位置的<code>小于基准点</code>的数，当然不怕和a[left]交换位置；<br>   然而当i先动，若是不可避免地遇上了j，此时的j是先前被交换过来的那个 <code>旧i</code>位置的<code>大于基准点</code>的数，当然不能和a[left]交换位置，否则新的a[left]不就一定会&gt;<code>基准点</code>咯！</strong></em></p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>   那么，如果左小右大，应该j先动，是不是说左大右小，就是i先动？让我们看下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left];</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &lt;= pivot)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[i++] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &gt;= pivot)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[j--] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    <span class="built_in">quicksort</span>(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quicksort</span>(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这是gpt给的，当然经过验证是正确的代码。我们可以看到，用这种方式，我们确实可以做到左小右大。经过今天的分析，我们能得到一个结论：i和j的移动顺序和得到的数组的要求有密切的关系：要求 &#x3D;&#x3D; 左小右大？ j 先动 : 要求 &#x3D;&#x3D; 左大右小？ : i 先动 : 俺也不知道。<br>   （容我写个嵌套三目结束今天的战斗！）</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> c++ </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My test blog^_^</title>
      <link href="/post/50b7c09a.html"/>
      <url>/post/50b7c09a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#日志<br>今天布置了网站封面，添加底部音乐元素， 增加留言板设置</p><hr><hr><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>代码测试：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>unbelievable </p><p>图片测试：</p><p><img src="http://mculover666.cn/blog/20191031/R4mWMXsrRKxu.png?imageslim"></p><p>引用测试：</p><blockquote><p>这是一条引用</p></blockquote><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>无序列表测试：</p><ul><li>哈哈</li><li>嘿嘿</li><li>吼吼</li></ul><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> test </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
