<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从比较器窥见java和c++的语言特性</title>
      <link href="/post/6611.html"/>
      <url>/post/6611.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于左老师的课上用的是java来教授，而我比较熟悉c++，所以我在借助gpt帮我将代码改为c++的同时，还和它对两种语言的相同和不同之处进行了比较详细的探讨。<br>探讨的内容包括：比较器的返回值差异，</p><blockquote><p>这是来自左老师的比较器代码（JAVA）</p></blockquote><div class='spoiler collapsed'>    <div class='spoiler-title'>        java    </div>    <div class='spoiler-content'>        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code01_Comparator</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> id;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> id, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任何比较器：</span></span><br><span class="line"><span class="comment">// compare方法里，遵循一个统一的规范：</span></span><br><span class="line"><span class="comment">// 返回负数的时候，认为第一个参数应该排在前面</span></span><br><span class="line"><span class="comment">// 返回正数的时候，认为第二个参数应该排在前面</span></span><br><span class="line"><span class="comment">// 返回0的时候，认为无所谓谁放前面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IdShengAgeJiangOrder</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据id从小到大，但是如果id一样，按照年龄从大到小</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o1.id != o2.id ? (o1.id - o2.id) : (o2.age - o1.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IdAscendingComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回负数的时候，第一个参数排在前面</span></span><br><span class="line"><span class="comment">// 返回正数的时候，第二个参数排在前面</span></span><br><span class="line"><span class="comment">// 返回0的时候，谁在前面无所谓</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o1.id - o2.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IdDescendingComparator</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o2.id - o1.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先按照id排序，id小的，放前面；</span></span><br><span class="line"><span class="comment">// id一样，age大的，前面；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IdInAgeDe</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o1.id != o2.id ? o1.id - o2.id : (o2.age - o1.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printStudents</span><span class="params">(Student[] students)</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Name : &quot;</span> + student.name + <span class="string">&quot;, Id : &quot;</span> + student.id + <span class="string">&quot;, Age : &quot;</span> + student.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(Integer[] arr)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o2 - o1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AComp</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果返回负数，认为第一个参数应该拍在前面</span></span><br><span class="line"><span class="comment">// 如果返回正数，认为第二个参数应该拍在前面</span></span><br><span class="line"><span class="comment">// 如果返回0，认为谁放前面都行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer arg0, Integer arg1)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arg1 - arg0;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return 0;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">Integer[] arr = &#123; <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">AComp</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;===========================&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;A&quot;</span>, <span class="number">4</span>, <span class="number">40</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;B&quot;</span>, <span class="number">4</span>, <span class="number">21</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;C&quot;</span>, <span class="number">3</span>, <span class="number">12</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;D&quot;</span>, <span class="number">3</span>, <span class="number">62</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;E&quot;</span>, <span class="number">3</span>, <span class="number">42</span>);</span><br><span class="line"><span class="comment">// D E C A B</span></span><br><span class="line"></span><br><span class="line">Student[] students = <span class="keyword">new</span> <span class="title class_">Student</span>[] &#123; student1, student2, student3, student4, student5 &#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;第一条打印&quot;</span>);</span><br><span class="line"></span><br><span class="line">Arrays.sort(students, <span class="keyword">new</span> <span class="title class_">IdShengAgeJiangOrder</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; students.length; i++) &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> students[i];</span><br><span class="line">System.out.println(s.name + <span class="string">&quot;,&quot;</span> + s.id + <span class="string">&quot;,&quot;</span> + s.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;第二条打印&quot;</span>);</span><br><span class="line">ArrayList&lt;Student&gt; studentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">studentList.add(student1);</span><br><span class="line">studentList.add(student2);</span><br><span class="line">studentList.add(student3);</span><br><span class="line">studentList.add(student4);</span><br><span class="line">studentList.add(student5);</span><br><span class="line">studentList.sort(<span class="keyword">new</span> <span class="title class_">IdShengAgeJiangOrder</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; studentList.size(); i++) &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> studentList.get(i);</span><br><span class="line">System.out.println(s.name + <span class="string">&quot;,&quot;</span> + s.id + <span class="string">&quot;,&quot;</span> + s.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// N * logN</span></span><br><span class="line">System.out.println(<span class="string">&quot;第三条打印&quot;</span>);</span><br><span class="line">student1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;A&quot;</span>, <span class="number">4</span>, <span class="number">40</span>);</span><br><span class="line">student2 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;B&quot;</span>, <span class="number">4</span>, <span class="number">21</span>);</span><br><span class="line">student3 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;C&quot;</span>, <span class="number">4</span>, <span class="number">12</span>);</span><br><span class="line">student4 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;D&quot;</span>, <span class="number">4</span>, <span class="number">62</span>);</span><br><span class="line">student5 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;E&quot;</span>, <span class="number">4</span>, <span class="number">42</span>);</span><br><span class="line">TreeMap&lt;Student, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((a, b) -&gt; (a.id - b.id));</span><br><span class="line">treeMap.put(student1, <span class="string">&quot;我是学生1，我的名字叫A&quot;</span>);</span><br><span class="line">treeMap.put(student2, <span class="string">&quot;我是学生2，我的名字叫B&quot;</span>);</span><br><span class="line">treeMap.put(student3, <span class="string">&quot;我是学生3，我的名字叫C&quot;</span>);</span><br><span class="line">treeMap.put(student4, <span class="string">&quot;我是学生4，我的名字叫D&quot;</span>);</span><br><span class="line">treeMap.put(student5, <span class="string">&quot;我是学生5，我的名字叫E&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (Student s : treeMap.keySet()) &#123;</span><br><span class="line">System.out.println(s.name + <span class="string">&quot;,&quot;</span> + s.id + <span class="string">&quot;,&quot;</span> + s.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    </div></div><div class='spoiler collapsed'>    <div class='spoiler-title'>        gpt优化后的c++代码    </div>    <div class='spoiler-content'>        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> std::string&amp; name, <span class="type">int</span> id, <span class="type">int</span> age)</span><br><span class="line">        : <span class="built_in">name</span>(name), <span class="built_in">id</span>(id), <span class="built_in">age</span>(age) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Comparator functions</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">idShengAgeJiangOrder</span><span class="params">(<span class="type">const</span> Student&amp; o1, <span class="type">const</span> Student&amp; o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.id != o2.id ? (o1.id &lt; o2.id) : (o2.age &lt; o1.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">idAscendingComparator</span><span class="params">(<span class="type">const</span> Student&amp; o1, <span class="type">const</span> Student&amp; o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.id &lt; o2.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">idDescendingComparator</span><span class="params">(<span class="type">const</span> Student&amp; o1, <span class="type">const</span> Student&amp; o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o2.id &lt; o1.id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">idInAgeDe</span><span class="params">(<span class="type">const</span> Student&amp; o1, <span class="type">const</span> Student&amp; o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.id != o2.id ? (o1.id &lt; o2.id) : (o2.age &lt; o1.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">acomp</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; a, <span class="type">const</span> <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudents</span><span class="params">(<span class="type">const</span> std::vector&lt;Student&gt;&amp; students)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> Student&amp; student : students) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; student.name &lt;&lt; <span class="string">&quot;, Id: &quot;</span> &lt;&lt; student.id &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; student.age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; arr = &#123; <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using the AComp comparator</span></span><br><span class="line">    <span class="comment">//std::sort(arr.begin(), arr.end(), [](int a, int b) &#123; return b &lt; a; &#125;);</span></span><br><span class="line">    std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), acomp);</span><br><span class="line">    <span class="built_in">printArray</span>(arr);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;Student&gt; students = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;A&quot;</span>, <span class="number">4</span>, <span class="number">40</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;B&quot;</span>, <span class="number">4</span>, <span class="number">21</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;C&quot;</span>, <span class="number">3</span>, <span class="number">12</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;D&quot;</span>, <span class="number">3</span>, <span class="number">62</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;E&quot;</span>, <span class="number">3</span>, <span class="number">42</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using the idShengAgeJiangOrder comparator</span></span><br><span class="line">    std::<span class="built_in">sort</span>(students.<span class="built_in">begin</span>(), students.<span class="built_in">end</span>(), idShengAgeJiangOrder);</span><br><span class="line">    <span class="built_in">printStudents</span>(students);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using a map with id as key and Student as value</span></span><br><span class="line">    <span class="function">std::map&lt;Student, std::string, <span class="title">decltype</span><span class="params">(idAscendingComparator)</span>*&gt; <span class="title">studentMap</span><span class="params">(idAscendingComparator)</span></span>;</span><br><span class="line">    studentMap.<span class="built_in">insert</span>(&#123; &#123;<span class="string">&quot;A&quot;</span>, <span class="number">4</span>, <span class="number">40</span>&#125;, <span class="string">&quot;I am student 1, my name is A&quot;</span> &#125;);</span><br><span class="line">    studentMap.<span class="built_in">insert</span>(&#123; &#123;<span class="string">&quot;B&quot;</span>, <span class="number">4</span>, <span class="number">21</span>&#125;, <span class="string">&quot;I am student 2, my name is B&quot;</span> &#125;);</span><br><span class="line">    studentMap.<span class="built_in">insert</span>(&#123; &#123;<span class="string">&quot;C&quot;</span>, <span class="number">4</span>, <span class="number">12</span>&#125;, <span class="string">&quot;I am student 3, my name is C&quot;</span> &#125;);</span><br><span class="line">    studentMap.<span class="built_in">insert</span>(&#123; &#123;<span class="string">&quot;D&quot;</span>, <span class="number">4</span>, <span class="number">62</span>&#125;, <span class="string">&quot;I am student 4, my name is D&quot;</span> &#125;);</span><br><span class="line">    studentMap.<span class="built_in">insert</span>(&#123; &#123;<span class="string">&quot;E&quot;</span>, <span class="number">4</span>, <span class="number">42</span>&#125;, <span class="string">&quot;I am student 5, my name is E&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; entry : studentMap) &#123;</span><br><span class="line">        <span class="type">const</span> Student&amp; s = entry.first;</span><br><span class="line">        std::cout &lt;&lt; s.name &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; s.id &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; s.age &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>    </div></div><h1 id="构造函数的区别："><a href="#构造函数的区别：" class="headerlink" title="构造函数的区别："></a>构造函数的区别：</h1><p>首先，我发现两种语言在构造函数上不太一样。</p><table><thead><tr><th>语言</th><th>代码示例</th><th>初始化方式</th></tr></thead><tbody><tr><td>C++</td><td><code>cpp Student(string name, int id) : name(name), id(id) &#123;&#125; </code></td><td>初始化列表</td></tr><tr><td>Java</td><td><code>java public Student(String name, int id) &#123;     this.name = name;     this.id = id; &#125; </code></td><td>构造函数体内赋值</td></tr></tbody></table><p>我发现原代码没有用初始化列表来赋值，于是查询资料：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在 Java 中，构造函数的语法不支持像 C++ 中的初始化列表一样的方式来进行构造时赋值。在 Java 中，你需要在构造函数的方法体内手动对成员变量进行赋值。 </span><br><span class="line">如果你在意初始化效率，可以考虑使用 Java 中的双重检查锁定等方式来优化对象的创建过程。</span><br></pre></td></tr></table></figure><p><strong>“双重检查锁”通常用于实现单例模式，这意味着在整个应用程序中只有一个实例。通过使用双重检查锁，可以在多线程环境中确保只有一个线程能够成功初始化对象，并且其他线程会等待或被阻塞，以避免并发初始化的问题。</strong></p><p>我立马联想到了c++中的“静态对象”，<strong>在C++中，可以使用静态成员变量来实现类级别的单例对象。静态成员变量只在类的生命周期内存在一个实例，并且它在类加载时被初始化。这样，每次使用这个类的对象时，都是引用同一个静态对象实例。</strong></p><p>但是，查阅资料知道，虽然这两种方式都可以实现对象的单例特性，但在细节上存在一些差异。双重检查锁主要用于在多线程环境下确保单例对象的正确初始化，而C++的静态对象则是一种在类级别上实现单例的方式，不涉及多线程的同步问题。</p><h1 id="函数对象声明的区别"><a href="#函数对象声明的区别" class="headerlink" title="函数对象声明的区别"></a>函数对象声明的区别</h1><table><thead><tr><th>特点</th><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>实现方式</td><td>实现Comparator接口，重写compare方法</td><td>创建函数对象类，重载函数调用操作符()</td></tr><tr><td>返回值</td><td>整数值，负数表示o1小于o2，正数表示o1大于o2</td><td>布尔值，true表示o1小于o2，false表示o1大于o2</td></tr><tr><td>命名空间</td><td>需要使用类名限定</td><td>可在局部或命名空间内使用</td></tr><tr><td>比较规则</td><td>返回负数、0、正数分别表示小于、等于、大于</td><td>返回true表示小于，false表示大于</td></tr></tbody></table><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">implements</span> <span class="title class_">Comparator</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o2 - o1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComp</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; o1, <span class="type">const</span> <span class="type">int</span>&amp; o2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2 &lt; o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="java的这些key都是什么意思？"><a href="#java的这些key都是什么意思？" class="headerlink" title="java的这些key都是什么意思？"></a>java的这些key都是什么意思？</h2><div class='spoiler collapsed'>    <div class='spoiler-title'>        java    </div>    <div class='spoiler-content'>        <p>public: 是一个访问修饰符，表示被修饰的类、方法或变量可以在任何地方被访问，没有访问限制。</p><p>static: 是一个关键字，用于创建静态成员，包括静态方法、静态变量等。静态成员属于类本身，而不是类的实例。可以通过类名直接访问静态成员，而无需创建对象。</p><p>class: 是一个关键字，用于定义类。类是 Java 中用于创建对象的模板，它包含属性（成员变量）和方法。<br>综合起来，当使用 public static 修饰类或方法时，具体含义如下：<br>ublic class: 定义一个公共类，可以被其他类访问。公共类可以在任何地方被使用。</p><p>public static class: 定义一个公共静态内部类。静态内部类是一个嵌套在其他类中的类，但它与外部类的实例无关，可以通过外部类名直接访问，无需创建外部类的对象。</p><p>public static method: 定义一个公共静态方法。静态方法属于类而不是类的实例，可以通过类名直接调用，无需创建对象。</p>    </div></div><p>而c++就比较熟悉：class 代表声明类，内部用public、private、protected区分访问权限。</p><h1 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h1><p>return o1.id !&#x3D; o2.id ? (o1.id &lt; o2.id) <br>简洁，美观~</p><h1 id="优雅-翩翩起舞的lambda"><a href="#优雅-翩翩起舞的lambda" class="headerlink" title="优雅-翩翩起舞的lambda"></a>优雅-翩翩起舞的lambda</h1><p>C++11引入的特性：Lambda表达式。</p><blockquote><p>Lambda 表达式是C++11引入的特性，它允许你在需要的地方创建匿名的、一次性使用的函数。</p></blockquote><p>例如，在sort函数中，可以直接调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br></pre></td></tr></table></figure><p>创建treeMap，也可以直接调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Student, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((a, b) -&gt; a.id - b.id);</span><br></pre></td></tr></table></figure><h1 id="Map-vs-TreeMap"><a href="#Map-vs-TreeMap" class="headerlink" title="Map vs TreeMap"></a>Map vs TreeMap</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::map&lt;Student, std::string, <span class="title">decltype</span><span class="params">(idAscendingComparator)</span>*&gt; <span class="title">studentMap</span><span class="params">(idAscendingComparator)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt;Student, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;((a, b) -&gt; (a.id - b.id));</span><br></pre></td></tr></table></figure><table><thead><tr><th>特点</th><th>C++</th><th>Java</th></tr></thead><tbody><tr><td>数据结构</td><td>std::map&lt;Student, std::string&gt; studentMap;</td><td>TreeMap&lt;Student, String&gt; treeMap;</td></tr><tr><td>有序映射</td><td>有序映射</td><td>有序映射</td></tr><tr><td>自定义比较器</td><td>是</td><td>是</td></tr></tbody></table><pre><code>                             |</code></pre><p>| 比较器设置方式     | 在创建实例后通过函数指针设置                | 在创建实例时通过 Lambda 表达式设置            |<br>| Lambda 表达式     | 适用                                       | 适用                                          |<br>| 代码示例           | <code>std::map&lt;Student, std::string&gt; studentMap(idAscendingComparator);</code> | <code>TreeMap&lt;Student, String&gt; treeMap = new TreeMap&lt;&gt;((a, b) -&gt; (a.id - b.id));</code> |</p><p>When input data whose key has already been in it, both Map andTreeMap will not cover the previous data of the same key, and the new data will be discarded and unaccepted. </p><h1 id="c-auto-vs-it"><a href="#c-auto-vs-it" class="headerlink" title="c++: auto vs it"></a>c++: auto vs it</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (const auto&amp; entry : studentMap) &#123;</span><br><span class="line">    const Student&amp; s = entry.first;</span><br><span class="line">    std::string s1 = entry.second;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s.name &lt;&lt; &quot;,&quot; &lt;&lt; s.id &lt;&lt; &quot;,&quot; &lt;&lt; s.age&lt;&lt;&quot;  &quot;;</span><br><span class="line">    std::cout &lt;&lt; s1&lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这一行，我坐不住了，心想，auto有没有可以替代的方案？<br>于是，查阅资料，得到如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;Student, std::string, decltype(idAscendingComparator)*&gt;::const_iterator it;</span><br><span class="line">for (it = studentMap.begin(); it != studentMap.end(); ++it) &#123;</span><br><span class="line">    const Student&amp; s = it-&gt;first;</span><br><span class="line">    std::string s1 = it-&gt;second;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; s.name &lt;&lt; &quot;,&quot; &lt;&lt; s.id &lt;&lt; &quot;,&quot; &lt;&lt; s.age &lt;&lt; &quot;  &quot;;</span><br><span class="line">    std::cout &lt;&lt; s1 &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，可以用it来代替auto，只不过要使用 std::map 的迭代器类型，但会使代码变得更冗长一些。</p><blockquote><p>总的来说，使用 auto 是更为简洁和灵活的方式，因为它允许编译器根据上下文来推断类型。如果你手动指定类型，需要确保类型匹配并且正确。</p></blockquote><h1 id="JAVA的良好特性"><a href="#JAVA的良好特性" class="headerlink" title="JAVA的良好特性"></a>JAVA的良好特性</h1><h2 id="默认传递引用"><a href="#默认传递引用" class="headerlink" title="默认传递引用"></a>默认传递引用</h2><h2 id="数组自带大小信息"><a href="#数组自带大小信息" class="headerlink" title="数组自带大小信息"></a>数组自带大小信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法接受一维数组作为参数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">processArray</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法接受二维数组作为参数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2DArray</span><span class="params">(<span class="type">int</span>[][] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : arr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : row) &#123;</span><br><span class="line">                System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[][] arr2 = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        processArray(arr1);</span><br><span class="line">        process2DArray(arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相比之下，c++的特性是最难绷的，起码上述Java的两个特性c++都没有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接受一维数组作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接受二维数组作为参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process2DArray</span><span class="params">(<span class="type">int</span> arr[][<span class="number">3</span>], <span class="type">int</span> rows, <span class="type">int</span> cols)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; ++j) &#123;</span><br><span class="line">            std::cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> arr2[][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">processArray</span>(arr1, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">process2DArray</span>(arr2, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>【完】</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/post/about.html"/>
      <url>/post/about.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h2 id="座右铭"><a href="#座右铭" class="headerlink" title="座右铭"></a>座右铭</h2><blockquote><p>“Real success embodies Personality, Purpose, and Panache.”</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我出生在湖南，在深圳长大。从小就热衷于各种运动，这让我长期保持乐观开朗的性格。我喜欢魔方、24点和足球，足球能够一次颠起400次，它们是我的兴趣和挑战。</p><p>我热衷于解各种问题，享受解决难题带来的成就感。我正在专注地学习人工智能领域，希望将来成为一名有成就的工程师。</p><p>我相信生活中的每一步都是一次学习，我愿意踏实前行，迎接未来的挑战。尽管未来可能充满了不确定性，但我怀揣一颗坚定的心，愿意持续不断地追求自己的目标，用一颗永不言败的心去迎接未知。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>阅读加密禅师的小本本</title>
      <link href="/post/7ca1.html"/>
      <url>/post/7ca1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h2 id="命运"><a href="#命运" class="headerlink" title="命运"></a>命运</h2><blockquote><p>@禅师<br>    　　一直觉得人的生命只有<code>惯性</code>，并没有命运。<br>下一秒钟做什么，只是不太容易明显改变下下秒的状态，但却对<code>几个月或若干年后的我们完全可以有重大的颠覆性影响</code>。<br><br>所以，<code>永远别</code>考虑用“这是宿命”、“命中定数”这类说辞来<code>否定</code>未来的任何<code>可能性</code>，或者回避我们需要<code>承担</code>的任何<code>责任</code>。<br>下午10:09 · 2023年8月7日<br>    － 逃避现实是否也是一种惯性呢？如何才能停止逃避现实，改变命运呢？<br>    － 禅师：逃避现实是一种行为。你下一秒不逃避现实了，你的遭遇往往不会立刻就巨变，需要你<code>坚持</code>个<code>几个月不逃避现实才会明显变化</code>——这是<code>惯性</code>。</p></blockquote><blockquote><p>@ 花花<br>真心建议:趁着年轻多做有积累的工作<br><code>对于消耗青春的工作没必要碰</code>!<br>每当我看到街上送着外卖的男男女女，我的心里就忍不住地哗啦啦下雨…<br>趁着年轻为什么不去做有<code>积累</code>的事情，什么叫有积累啊?<br>时间过去了，房子也起来了，大多数人做的事情无非是在消耗青春，没有任何积累… 没有积累，年龄越大越廉价，不做这些工作做什么?<br>做需要发挥脑力的事情，做<code>越老越吃香</code>的行业。<code>越来越吃香</code>的行业&#x3D;写作&#x2F;咨询&#x2F;运营&#x2F;流量&#x2F;捌字&#x2F;风水&#x2F;撩汉&#x2F;疗愈&#x2F;心理&#x2F;吃、穿、住、行….<br>有机会一定要多见识<code>见识外面的世界</code>，没见过世面自然目光短浅，目光短浅自然会做无用式循环，做无用式循环自然会成为地地道道的穷人，成为穷人自然会生活在社会边缘，生活在社会边缘自然会被社会淘汰，被社会淘汰了还能做点儿什么?<br>小时候，没见过世界，以为世界很大，大了，接触的人多了，才知道:物以类聚人以群分这辈子自己到底怎么样，是看父母做什么，我们能复制父母什么 或是看身边的人做什么，我们能跟着做点儿什么。<br>做无用式循环的慢慢真成了废物，只关心发家致富的z后真的发家致富了。 生活是什么，它从来不说。芸芸众生<code>做了什么，便成了什么</code>。</p></blockquote><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><blockquote><div class='spoiler collapsed'>    <div class='spoiler-title'>        时间控制和节省：    </div>    <div class='spoiler-content'>        <blockquote><p>@xfli5<br>1、不浪费自己的时间去管别人闲事、关注别人生活。<br>2、真本事都是偷来的，很少有人真心教你，教你也教不会。<br>3、学习不是目的，用起来才是，换来钱才是。<br>4、你穷并不是因为你不够努力，而是你没有找到正确的方式——囤饼。\<br>5、如果问题有办法解决，那就没有必要担心。<br>6、如果问题没有办法解决，那么担心也没有用。<br>7、看透人际关系，除了父母和子女必须负责任，其他人来去自由，不执着。<br>8、囤饼这件事，坚持下来真的很难，不信你试试！</p></blockquote>    </div></div></blockquote><blockquote><p>@ 章工<br>珍惜时间，<code>不需要三更灯火五更鸡</code>，不是点灯熬油，而是保持生活作息的节奏和秩序。<br>一天天坚持不懈，把精力最好的时间投入到<code>重要的事情</code>上，等待持续积累带来的复利增长。<br>如果你的生活太琐碎，不妨培养早起<code>读书写字</code>的习惯。<code>开启一日琐事之前</code>，<code>榨干最好的脑力</code>，这也是一种<code>高效的时间管理</code>。</p></blockquote><h2 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h2><h3 id="20个剃刀法则"><a href="#20个剃刀法则" class="headerlink" title="20个剃刀法则"></a>20个剃刀法则</h3><blockquote><div class='spoiler collapsed'>    <div class='spoiler-title'>        20个最具价值的思维剃刀，掌握以下经验法则，能让你做出更好的决策：    </div>    <div class='spoiler-content'>        <ol><li><p><strong>费曼剃刀（The Feynman Razor）</strong><br>如果你不能向一个<code>5岁的孩子</code>解释某个<code>复杂</code>的术语，你就没有真正理解它。</p></li><li><p><strong>聪明的朋友剃刀（The Smart Friends Razor）</strong><br>如果你<code>最聪明的朋友</code>对某件事感兴趣，那这件事就<code>值得</code>关注一下。</p></li><li><p><strong>房间剃刀（The Rooms Razor）</strong><br>如果你可以在进入两个房间之间做选择，选择<code>你更可能是房间里最笨的人</code>的那个房间。一旦你进入房间，<code>少说多听</code>。</p></li><li><p><strong>竞技场里的人剃刀（The Man in the Arena Razor）</strong><br>在场边扔石头很容易，但要进入竞技场却很难。如果你想获得<code>巨大的回报</code>，就必须进入<code>竞技场</code>。</p></li><li><p><strong>意外剃刀（The Serendipity Razor）</strong><br>有些我们所谓的“运气”其实是无数个微观行为的宏观结果。而你的日常习惯造就了无数个微观行为，<code>好的习惯</code>会让你更有可能获得意外之喜。</p></li><li><p><strong>上坡决策剃刀（The Uphill Decision Razor）</strong><br>当面临两个选择时，选择<code>短期内比较困难</code>的那个。</p></li><li><p><strong>难得机会剃刀（The Rare Opportunity Razor）</strong><br>有一种罕见的机会，一般人一生中<code>只能碰到0到1次</code>。它们看起来很<code>吓人</code>，但<code>回报</code>却是<code>巨大</code>的。如果你有幸遇到这样的机会，那就<code>抓住它</code>。</p></li><li><p><strong>巴菲特声誉剃刀（The Buffett Reputation Razor）</strong><br><code>建立一个声誉需要20年，而毁掉它只需要5分钟。</code>如果你<code>考虑到这一点</code>，<code>就会</code>有<code>不同</code>的做法。<em><strong>声誉真的对于人很重要！</strong></em></p></li><li><p><strong>叙事谬误剃刀（The Narrative Fallacy Razor）</strong><br>人类是喜欢<code>讲故事</code>的生物，我们把一系列事件编织在一起，以寻找因果关系，而现实可能只是<code>运气</code>的结果。</p></li><li><p><strong>时间亿万富翁剃刀（The Time Billionaire Razor）</strong><br>当你在两条道路之间做选择时，要<code>选择</code>最<code>珍视你的时间价值</code>的那条路。</p></li><li><p><strong>意见剃刀（The Opinion Razor）</strong><br>如果你并<code>不比对方更了解他们的论点</code>，就<code>不</code>要<code>允许自己</code>对此<code>发表</code>任何<code>意见</code>。</p></li><li><p><strong>担心剃刀（The Worrying Razor）</strong><br>如果你问了一个问题，而对方的反应是<code>提高嗓门、摆摆手或嘲笑</code>，你可能<code>应该``更深入地挖掘</code>这个问题。（？什么意思呢，可能我的段位还是不够吧。）</p></li><li><p><strong>吹牛者剃刀（The Boasters Razor)</strong><br>真正成功的人<code>很少</code>觉得<code>有必要夸耀</code>自己的成功。</p></li><li><p><strong>牛顿的烈焰激光剑（Newton’s Flaming Laser Sword）</strong><br>如果一件事<code>不能通过实验或观察来解决，那它就不值得讨论。</code>记住这一点将让你避免在网上和现实生活中于无谓的争论上浪费大量的时间。<em><strong>（实测真的很有道理——可以用这个法则避免百分之五十的争论）</strong></em></p></li><li><p><strong>希钦斯剃刀（Hitchens’ Razor）</strong><br>可以在<code>没有证据的情况下断言</code>的东西，<code>也可以</code>在<code>没有证据</code>的情况下<code>驳回</code>。</p></li><li><p><strong>勇气剃刀（The Grit Razor）</strong><br>如果必须在两个实力相当的人之间做出选择，<code>选择曾“被打脸”的那个</code>。被打过的人（无论是隐喻上的还是字面上的）很可能拥有真正的勇气。（也有可能才有真正的智慧）</p></li><li><p><strong>汉隆剃刀（Hanlon’s Razor）</strong><br>永远<code>不要把可以用愚蠢</code>来充分解释的事情，<code>归咎于恶意</code>。</p></li><li><p><strong>乐观者剃刀（The Optimist Razor）</strong><br>在选择和谁共度时光时，优先考虑花更多的时间和<code>乐观者</code>在一起。</p></li><li><p><strong>“保持不变”剃刀（The “What Stays the Same” Razor）</strong><br><code>预测未来</code>是困难的，在为未来做准备时，要关注那些<code>不变的东西</code>。</p></li><li><p><strong>保罗·格雷厄姆<code>疯狂想法</code>剃刀（The Paul Graham Crazy Idea Razor）</strong><br>如果有人提出一个看似疯狂的想法，问问你自己：<br>　　（1）他们是这个领域的<code>专家</code>吗？<br>　　（2）他们是很<code>讲道理</code>的人吗？<br>如果你对（1）和（2）的回答都是肯定的，就应该认真对待这个想法，因为这可能是对未来的押注。</p></li></ol>    </div></div></blockquote><h3 id="24个人生感悟"><a href="#24个人生感悟" class="headerlink" title="24个人生感悟"></a>24个人生感悟</h3><blockquote><div class='spoiler collapsed'>    <div class='spoiler-title'>        24个人生真相与感悟，越早知道越好：    </div>    <div class='spoiler-content'>        <ol><li><p>很多人就是因为<code>好得不彻底，坏得不纯粹</code>，所以才会陷入痛苦的境地当中。</p></li><li><p>千万<code>不要用你以为对人好的方式对别人好</code>，那只是<code>道德式的自我感动</code>罢了。</p></li><li><p>大多数人学习的本质，只停留在“<code>假装很努力</code>”的层面。</p></li><li><p>现在我们接触到的很多信息，大多都是<code>引起人怨恨和焦虑</code>的(令人感动和引发正义感的信息同样是毒药)。<br>所以你必须<code>非常深刻、非常用力地活着</code>，才能<code>免受这些垃圾信息的侵袭</code>，才<code>不会被人操纵</code>。(<em><strong>是啊，每天的时事几乎没几个是真的带来”正能量“的，要时刻警惕避免这些垃圾信息的侵扰！</strong></em>)</p></li><li><p>那个离开你的人，永远别原谅他。<br>他想离开你的瞬间，必定做了<code>利益的权衡</code>，离开你，才符合他<code>更大的利益</code>。</p></li><li><p>多年以来从<code>学校学的那套普世价值观</code>，<code>完美地避开了赚钱</code>，避开了改命这一条道路。<br>对于寒门出身的孩子而言，你接收的很可能不是<code>十几年的教育</code>，而是<code>十几年教育的伤害</code>。</p></li><li><p>想要提升，先<code>清空</code>脑子里的<code>垃圾思维</code>，多跟有成果的人学习。</p></li><li><p>聪明人都知道，<code>不到临死前，不能把权力和真金白银交出去</code>。自己手里一旦没了筹码，任何人都可能背叛自己。(想想也是！)</p></li><li><p>打工只是为了<code>去积累一定的试错成本</code>，想要改命，<code>不断去尝试</code>才是最佳的途径，而<code>不是拿着死工资过生活</code>。</p></li><li><p>不谈感情，聪明人总是把<code>精力放到事业上去</code>，因为他们知道<code>感情是最不靠谱的投资</code>。</p></li><li><p>工作的<code>本质</code>是<code>提升</code>，任何<code>逃避这个事情的动作都费动作</code>。</p></li><li><p>没钱没有什么格局不格局，理想不理想，只有当你<code>收入提高了，格局自然就上来了</code>。做一个尊重市场规则，<code>尊重等价交换</code>的人。</p></li><li><p>聪明人不会哭诉自己已经付出了多少，他们会着眼于未来，<code>谈自己未来会有什么价值</code>，会<code>持续为对方带来多少利益</code>。</p></li><li><p>聪明人<code>往往不借钱给别人</code>。凡是来找你借钱的，95%的情况是对方看你老实本分好欺负。<br>如果你真借给他，当你找他还钱的时候，他极大概率就是大爷。(<em><strong>借出去就当这钱弄丢了！</strong></em>)</p></li><li><p><code>看破不说破</code>。(<em><strong>我要好好锻炼这个能力！</strong></em>)就像是偷电动车的小子说的那样：里面的人个个说话都好听，这些人之所以说话好听，是因为他们说真话。而到了外面，是没人会讲真话的。聪明人都知道，讲真话是要倒霉的，全家跟着倒霉的那种。</p></li><li><p>大张旗鼓的离开其实都是试探，<code>真正的离开是没有告别的</code>。</p></li><li><p><code>聪明人为穷人说话，帮富人办事</code>。(<em>我靠！真特么对</em>)</p></li><li><p>人和人的三观，是不可能真正一致的，<code>不要企图去寻找一个和你三观一致的伴侣</code>。(难道根本就不去找？还是迁就呢？)</p></li><li><p>聪明人的朋友不多，所以只能像高级的哲人独处着。这并不是因为他想孤独，而是因为在他的周围<code>找不到他的同类</code>。</p></li><li><p>伤害你的不是对方的绝情，而是你<code>心存幻想</code>的坚持。无法许下承诺也无法兑现承诺的男人，就要去接受女人随时离开的结局。</p></li><li><p>男女之间之所以能互相吸引，是因为他们能互相满足对方的<code>需求</code>(精神需求、物质需求、生理需求、面子需求)。(本质层面当然是这样)</p></li><li><p><code>大喜大悲，看清自己；大起大落，看清朋友</code>。(大道至简)</p></li><li><p>真正有价值，<code>对提升有帮助的知识</code>，往往是<code>不会有人免费分享</code>的。</p></li><li><p><code>人越聪明，话越少，威严越盛</code>。</p></li><li><p>能<code>改变自己</code>的都是“神”，想着去改变别人的都是神经病。成年人的世界，只饰选，不教育。</p></li></ol>    </div></div></blockquote><blockquote><div class='spoiler collapsed'>    <div class='spoiler-title'>        《哈佛幸福课》中10个很受用的观点：    </div>    <div class='spoiler-content'>        <ol><li><p>允许自己<code>有缺点、犯错误</code>，允许自己做人而不是神。在合理合法的范围内，对自己宽容一点。</p></li><li><p>好东西太多不是好事，<code>两首好歌同时放</code>，<code>就是噪音</code>。<br>所以，留下自己真正想要的，<code>扔掉并没有很想要的</code>，就算它很珍贵。比物质充裕更能带来幸福的是时间充裕。</p></li><li><p>不要因为害怕失败而放弃去尝试自己<code>真正想做</code>的事，勇气并不是没有畏惧，而是<code>有了畏惧还坚持向前</code>。</p></li><li><p>研究表明，失败真的是成功之母。<code>最成功的人往往是失败得最多的</code>。学会面对自己的失败，在失败中学习。这是学习的不二法门。</p></li><li><p>最能给人幸福感的东西，是<code>良好的人际关系</code>。亲密关系比很多事情都重要，它会给人带去有治愈能力的爱和温暖。</p></li><li><p>从希望被认可变成希望被了解。一个人很多时候不是因为完美而被喜欢，是因为真实而被喜欢。因为<code>真实而被喜欢</code>，才是<code>持久</code>、<code>轻松</code>、<code>可持续发展</code>的。</p></li><li><p><code>多问正面</code>的问题，正面的问题会<code>引导</code>人<code>正向地思考</code>。</p></li><li><p>遇到痛苦的事情，<code>不要反复咀嚼</code>你的<code>痛苦</code>，因为会越嚼越痛苦。</p></li><li><p>去了解自己是哪种人，选择适合自己的<code>恢复和放松方式</code>。</p></li><li><p><code>锻炼是刚需</code>，运动是一项对现在和未来的投资。</p></li></ol>    </div></div></blockquote><blockquote><div class='spoiler collapsed'>    <div class='spoiler-title'>        让人碌碌无为的一些原因：    </div>    <div class='spoiler-content'>        <ol><li><p><code>牺牲健康</code>、时间、精力和机会，去换取少量的金钱。<br>不会<code>洗择``消耗金钱</code>，来<code>让自己充满活力</code>、拥有<code>自主时间</code>及名种可能性。</p></li><li><p>看似不惧风险，实则<code>喜欢赌博</code>、<code>投机</code>、<code>借贷</code>、<code>胡乱交友</code>、<code>不注意言行</code>并得罪小人。<br>而富人非常<code>谨慎</code>，注重<code>风险管理</code>，做决策之前充分<code>调研</code>，为拥有的套上层层铠甲，明白“<code>善战者无赫赫之功</code>”(<em><strong>仅凭一时的战绩而获得名声的人，不一定能够产生持久的影响或被人所敬仰。</strong></em>)。</p></li><li><p>被眼界所限，缺乏对<code>关键学习</code>、<code>成长可能性</code>、<code>需结交贵人</code>的识别力。<br>即使有<code>意识</code>，也没有<code>积累资源</code>，更容易错失飞跃的机会。</p></li><li><p>喜欢<code>怪罪环境</code>，很难找到内因。认为环境不公、出生不好、运气不行、别人不帮助自己，是他们困难的决定因素。因此更容易屈从于环境，不敢去<code>反抗和改变</code>。</p></li><li><p>在思想上服从于权威，在情感上和亲友依附，需要不断向周围<code>索取</code>情绪。<br>很难忍受孤独，很难有时间学习，也很难有孤军奋斗的精神。</p></li><li><p>很多网络上的炫富信息是虚假的，但由于并不熟悉真正富裕的生活，所以容易相信<code>虚假信息</code>，从而加剧<code>焦虑</code>。</p></li><li><p>由于普遍缺乏资源，行动机会更少，所以常常<code>空想各种可能性</code>。<br>但缺乏<code>基础的实践锤炼</code>、<code>不习惯心理建设</code>、<code>熟练度</code>更<code>低</code>，愈发<code>难以实践</code>。</p></li><li><p>由于生长环境的塑造而<code>缺乏真实信息</code>，更容易被性焦虑驱动、被道德绑架、被消费主义捆绑，从而<code>丧失自主选择</code>。</p></li></ol>    </div></div></blockquote><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 金玉良言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哲言 </tag>
            
            <tag> 终身学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度之星内训班竞赛题</title>
      <link href="/post/6673.html"/>
      <url>/post/6673.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h2 id="题目一-神奇排列"><a href="#题目一-神奇排列" class="headerlink" title="题目一 神奇排列"></a>题目一 神奇排列</h2><p>给定正整数n，求一个长度为2n的数组，满足：<br>1 数组由 1 ~ 2n 共2n个数字打乱组成，且每个数字出现一次<br>2 每个偶数位（从0开始）和其右边的数字（奇数位上）的和组成的长度为n的新数组是一个公差为1的等差数列</p><p>输入：</p><ul><li>第一行一个数字，test的次数</li><li>后面test行，每一行一个数字，为当前test的n<br>输出：</li><li>如果不能组成这样的2n长度数组，输出NO</li><li>如果可以，输出YES，并且打印数组</li></ul><p>样例：<p></p><blockquote><p>输入：</p></blockquote><ul><li>4<p>1<p>2<p>3<p>5<p></li></ul><blockquote><p>输出:</p></blockquote><ul><li>YES<p>2 1<p> NO <p>YES<p> 4 2 6 1 5 3 <p>YES <p>6 3 8 2 10 1 7 5 9 4</li></ul><p>这其实是一个技巧题。如果观察和稍加推导就发现：<br>1 偶数是一定会输出NO。因为中间的和会是一个.5的小数，整数凑不出来<br>2 所有的奇数，在前一半数组中奇数位的数字是n+1，后一半是n+2。我尝试证明，但是感觉有点点复杂。<br>3 既然这样，我们就写出来，在再验证看看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printarray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">2</span> * n + <span class="number">1</span> - (n &gt;&gt; <span class="number">1</span>) + j - i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">2</span>, j = <span class="number">0</span>; j &lt; (n &gt;&gt; <span class="number">1</span>); i += <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">2</span> * n + <span class="number">2</span> + j - i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> test = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; test;</span><br><span class="line">    <span class="keyword">while</span> (test--) &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printarray</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>输入 1 5 输出 6 3 8 2 10 1 7 5 9 4</code></p></li><li><p><code>输入 1 7 输出 8 4 10 3 12 2 14 1 9 7 11 6 13 5</code><br>看起来没毛病，我们再用对数器试一下</p></li></ul><div class='spoiler collapsed'>    <div class='spoiler-title'>        对数器版    </div>    <div class='spoiler-content'>        <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">printarray</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// int * originalarray = new int[2*n];</span></span><br><span class="line">    <span class="type">int</span>* processedarray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>*n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>*n; i++) &#123;</span><br><span class="line">        processedarray[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n; i += <span class="number">2</span>, j++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">2</span> * n + <span class="number">1</span> - (n &gt;&gt; <span class="number">1</span>) + j - i;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; tmp &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        processedarray[i] = processedarray[tmp] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">2</span>, j = <span class="number">0</span>; j &lt; (n &gt;&gt; <span class="number">1</span>); i += <span class="number">2</span>, j++) &#123;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">2</span> * n + <span class="number">2</span> + j - i;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; tmp &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        processedarray[i] = processedarray[tmp] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processedarray[i] != <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Oops!&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot; is bad!&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">                cout&lt;&lt;processedarray[i];            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">delete</span>[] processedarray;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">delete</span>[] processedarray;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="comment">// delete[] originalarray;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> test = <span class="number">10000</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> continue1 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (test--&amp;&amp;continue1)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            continue1 = <span class="built_in">printarray</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        n += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;n = &quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    </div></div><p>用暴力方法来gank，验证从1到2n，每一个数字是不是出现了，程序结果输出20001，意味着前n &#x3D; 1~10000都是正确的，基本上是可以确定没毛病了。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SAF会议_2023_08_03</title>
      <link href="/post/1e40.html"/>
      <url>/post/1e40.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h2 id="好处？"><a href="#好处？" class="headerlink" title="好处？"></a>好处？</h2><p><br>1 英语能力，口语听力阅读，大量 paper work<br><br>2 海外名校官方学分+成绩单（至少B+），实质性证明<br><br>3 推荐信（有机会，博士），本科生、名校研究生：海外名校本科老师的推荐信就够了(强推更好)<br><br>4 自信、人脉</p><h2 id="加州"><a href="#加州" class="headerlink" title="加州"></a>加州</h2><p>大学系统，不是分校。互相认可。</p><h2 id="加州大学洛杉矶分校-寒假大数据"><a href="#加州大学洛杉矶分校-寒假大数据" class="headerlink" title="加州大学洛杉矶分校-寒假大数据"></a>加州大学洛杉矶分校-寒假大数据</h2><img src="/post/1e40/page1.png" class="" title="洛杉矶分校大数据1"><br><img src="/post/1e40/page2.png" class="" title="洛杉矶分校大数据2"><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络第一章—体系结构笔记(未完)</title>
      <link href="/post/b13a.html"/>
      <url>/post/b13a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><h2 id="计算机网络的概述"><a href="#计算机网络的概述" class="headerlink" title="计算机网络的概述"></a>计算机网络的概述</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>计网是将独立功能的计算机系统通过通信设备与线路、软件、协议，实现资源共享和信息传递。<br>互连（通过通信链路互联互通）、自治（无主从关系）的计算机集合。</p><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>第一阶段：分散系统？ARPAnet，同一类型网络；不同网络互联？internet（TCP&#x2F;IP协议）-&gt;Internet（全世界最大的计算机网络）<br>节点+路由器 &#x3D; 网络； 网络*n &#x3D; 互联网<br>第二阶段：NSF+6大型计算机中心 &#x3D; 三级结构。校园网、企业网-&gt;地区网-&gt;主干网<br>第三阶段：多层次ISP结构（因特网服务提供）主干、地区、本地，网络管理权分散。网费：ISP服务费。因特网管理机构管理IP池。本地-&gt;地区-&gt;主干-&gt;地区-&gt;本地；本地-&gt;地区-&gt;IXP(因特网交换点)-&gt;地区-&gt;本地</p><h3 id="不同视角下的组成方式"><a href="#不同视角下的组成方式" class="headerlink" title="不同视角下的组成方式"></a>不同视角下的组成方式</h3><ul><li><h4 id="内部组成"><a href="#内部组成" class="headerlink" title="内部组成"></a>内部组成</h4><code>硬件、软件、协议</code></li><li><h4 id="整体组成–工作方式"><a href="#整体组成–工作方式" class="headerlink" title="整体组成–工作方式"></a>整体组成–工作方式</h4><code>边缘部分（接入的计算机，用户端）</code>  + <code>核心部分（提供服务）</code></li></ul><br>***边缘部分通信方式*** <br>  <p>端到端通信：进程（软件如QQ）之间的通信。两大模式<br>> C/S vs B/S: - C/S（Client & Server）常用，服务与被服务，如QQ- B/S（Browser & Server）> P2P- (peer to peer)设备间无固定身份，同时是客户和服务器，”我为人人人人为我“;<br><ul><li><h4 id="功能组成——实现数据通信和资源共享"><a href="#功能组成——实现数据通信和资源共享" class="headerlink" title="功能组成——实现数据通信和资源共享"></a>功能组成——实现数据通信和资源共享</h4></li></ul><p>数据通信：通信子网，包括：#3 <code>网络层</code>（路由器），#2 <code>数据链路层</code>（交换机，网桥），#1 <code>物理层</code>（集线器，中继器）。由传输介质、通信设备、相应协议组成。<br>中间：#4 <code>传输层</code>。<br>资源共享：资源子网，包括： #5 <code>会话层</code>，#6 <code>表示层</code>，#7 <code>应用层</code>。由相应软件和设备组成。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li><code>数据通信</code>（数据）</li><li><code>资源共享</code>（数据+硬件+软件）（如何处理请求？操作系统。）</li><li><code>分布式处理</code>（承担同意工作任务的不同部分，Hadoop）<ul><li>（-&gt;<code>提高可靠性</code>，<code>负载均衡</code>），</li></ul></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>范围:</li></ul><p><code>广域网(交换技术)</code> <code>城域网</code><br><code>局域网(-&gt;)广播技术)</code> <code>个人区域网</code></p><ul><li>使用者:<br>公用网（平民） 专用网（政府军队）   </li><li>交换技术:</li></ul><p><code>电路交换（占用资源+释放资源）</code> <code>报文交换/分组交换(存储转发)</code></p><ul><li>拓扑结构:<br>总线型，星形，环形，网状型</li><li>传输技术:<br>广播式（所有用户都知道）， 点对点网络（分组存储转发和路由选择机制）</li></ul><p>看到这里，来一张图片总结一下：</p><img src="/post/b13a/wangluocover1.png" class="" title="概述脑图"><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="速率专题"><a href="#速率专题" class="headerlink" title="速率专题"></a>速率专题</h3><p><code>带宽</code>：一般指某一链路上（两个点之间）支持的的“最高数据率”（即理想状态下的能力），单位：b&#x2F;s, kb&#x2F;s, Mb&#x2F;s, Gb&#x2F;s, Tb&#x2F;s  相邻10^3)<br><code>传播速率</code>：2.0E+8 m&#x2F;s<br><code>传输速率</code>：连接在网络上的<code>某一主机</code>在信道上传送数据位数的速率。也称数据率&#x2F;数据传输率&#x2F;比特率(传输数据位数的速率：b&#x2F;s, kb&#x2F;s, Mb&#x2F;s, Gb&#x2F;s, Tb&#x2F;s  相邻10^3)(理论值)<br><code>注意：存储容量数据位数的单位：B, kB, MB, GB, TB  相邻2^10, 1 Byte = 8 bit</code><br>吞吐量：单位时间通过<code>某个网络上（网卡）</code>或者<code>信道</code>或者<code>接口</code>的数据量(多对多)，受到<code>额定传输速率</code>和<code>带宽</code>的限制。</p><p><em><strong>发送的速率和接口关系比较大，而接受速率被缓存、线路质量等限制</strong></em><br>鉴于这三者的关系过于暧昧，我请教了gpt来答疑解惑：</p><ul><li>gpt解释之文字版</li></ul><blockquote><p>直接看结论：</p></blockquote><p>我们可以将这三个概念简单地理解为：<br><br><code>带宽：对信道能力的衡量，是理论上的最大数据传输能力。</code><br><code>吞吐量：在实际操作中，能够通过网络或信道成功传输的数据量。这是一个实际的测量值，通常受到网络状况（如延迟、数据丢失和重传等）的影响，所以吞吐量通常会小于带宽。</code><br><code>传输速率：针对特定的主机或设备，其在网络中发送数据的理论能力。</code></p><blockquote><p>我时间多，想看具体解释</p></blockquote><p>带宽：通常指的是 <em><strong>.<code>通信信道</code>的数据传输能力</strong></em>也就是单位时间内传送的数据量。比如，我们经常会听到10Mbps，100Mbps，1Gbps等说法，这些都是带宽的描述。带宽越大，<code>理论</code>上单位时间内可以传送的数据量就越大。然而，实际的数据传输量往往受到很多因素的影响，比如网络拥堵，数据丢失和重传等，因此实际的数据传输量通常会小于带宽。</p><p>吞吐量：吞吐量是指单位时间内成功传送的数据量。与带宽不同，吞吐量是一个实际的测量值，反映的是实际的数据传输效果，是对整个网络或者特定信道、接口的实际传输效果的度量。吞吐量受到许多因素的影响，比如带宽，网络延迟，数据丢失和重传等。<em><strong>你的网络吞吐量就是你<code>实际</code>下载文件的速度。</strong></em></p><p>传输速率：传输速率是指一个特定的主机或设备，单位时间内发送的比特数。与带宽相似，传输速率也是一个<code>理论值</code>。在实际应用中，由于需要对数据进行编码，添加错误检测和纠正码，以及其他协议开销，实际的数据传输速率通常会小于物理传输速率。通常情况下，我们所说的网络速度，比如10Mbps，100Mbps等，实际上是指的物理传输速率。实际的传输速率可能会受到许多因素的影响，比如网络拥塞，接口性能，发送数据的类型和大小。<em><strong>传输速率是针对单一主机或设备的特性，而不是整个网络或者信道的性能。</strong></em></p><blockquote><p>gpt解释之表格版</p></blockquote><img src="/post/b13a/image_2023-08-04_01-14-35.png" class="" title="gpt表格版"><h3 id="时延-延迟-迟延"><a href="#时延-延迟-迟延" class="headerlink" title="时延&#x2F;延迟&#x2F;迟延"></a>时延&#x2F;延迟&#x2F;迟延</h3><p>指数据从出发到目的地所需要的时间（单位：s）。<br>按先后顺序分为：<code>发送时延</code>，<code>传播时延</code>，<code>排队时延</code>，<code>处理时延</code></p><ul><li>发送时延(bit&#x2F;s)<br><code>主机接口</code>处用于<code>输出数据</code>所用总时间。公式：（数据长度）&#x2F;（信道带宽&#x2F;发送时率）。带宽对这的影响最大，常说的高速链路就是指发送时延低。</li><li>传播时延(m&#x2F;s)<br>路途中传输数据用时。公式：（信道长度）&#x2F;（电磁波传播数率）</li><li>排队时延<br>从 <code>数据到达目的地</code> 开始到 <code>数据被处理</code> 用时。即等待链路可用。</li><li>处理时延<br>检错、找出口用时。<img src="/post/b13a/shiyanwangdao.png" class="" title="时延"></li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>formula : 时延带宽积 &#x3D; 传播时延 * 带宽<br>bit &#x3D; s * (b&#x2F;s)<br>指：假设某主机不间断向服务器发送数据，第一个比特到达服务器时，整个信道上的比特数。亦即：信道满载时的比特数。亦即：以比特为单位的链路长度。</p><p>这是csdn一个博主的解释：</p><img src="/post/b13a/delaycsdn1.png" class="" title="时延带宽积"><p><br>原链接：</p><blockquote><p><a href="https://blog.csdn.net/ahLOG/article/details/116202211" target="_blank">延时带宽积</a></p></blockquote><h3 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h3><p>从发送的第一个bit开始计时，到服务器针对所接收数据而返回的信息到达发送方为止。<br>formula: 传播时延*2+末端处理时间<br>注意：跟传输时间没有半毛钱关系！<br>推导：RTT越大，在收到确认之前，可以发送的数据越多。</p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>信道利用率：有数据在信道上的时间&#x2F;总时间<br>网络利用率：信道利用率的加权平均值<br>与时延的近似关系：时延 &#x3D; -1&#x2F;(利用率-1)</p><img src="/post/b13a/guanxi.png" class="" title="时延"><h2 id="体系结构-参考模型"><a href="#体系结构-参考模型" class="headerlink" title="体系结构&amp;参考模型"></a>体系结构&amp;参考模型</h2><blockquote><p>计算机网络体系结构简称网络体系结构，是分层结构，是各层及其协议的集合</p></blockquote><h3 id="分层结构-协议-接口-服务"><a href="#分层结构-协议-接口-服务" class="headerlink" title="分层结构&#x2F;协议&#x2F;接口&#x2F;服务"></a>分层结构&#x2F;协议&#x2F;接口&#x2F;服务</h3><ul><li><h4 id="分层结构-实体"><a href="#分层结构-实体" class="headerlink" title="分层结构&#x2F;实体"></a>分层结构&#x2F;实体</h4>1 各层相互独立     <p>   2 每层之间交流尽可能少  <p> 3 促进标准化，每层用最合适的技术  <p>   4 层数相等的才称为<code>对等实体</code>，共用一套协议</li><li><h4 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h4>1 水平方向，对等实体 2 语法、语义、同步（顺序）的互通</li><li><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4>1 垂直方向 2 下层为上层提供服务，给上层提供服务所需要的<code>接口</code></li><li><h4 id="数据单元"><a href="#数据单元" class="headerlink" title="数据单元"></a>数据单元</h4>1 SDU-&gt;Service Data Unit， 服务数据单元，“原始数据”<br>2 PCI-&gt;Protocol Control Information，协议控制信息用于保持同步，例如序列号，校验和，帧类型。<br>3 PDU-&gt;Protocol Data Unit，协议数据单元，PDU &#x3D; PCI+SDU。</li><li>服务和接口不能跨层<blockquote><p>广义上，SDU，PCI，PDU可以指任何一层对应的数据</p></blockquote></li></ul><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>OSI参考模型 + TCP&#x2F;IP参考模型 &#x3D; 5层体系结构</p><h2 id="OSI参考模型（7层）"><a href="#OSI参考模型（7层）" class="headerlink" title="OSI参考模型（7层）"></a>OSI参考模型（7层）</h2><p>法定标准，IBM公司的SNA是第一个网络体系结构，后来又DEC的DNA，美国国防部的TCP&#x2F;IP。<br>ISO公司1984提供OSI模型，非垄断，支持异构网络系统的互联互通。理论成功，市场失败。</p><img src="/post/b13a/seven_level_structure.png" class="" title="七层结构：“物联网淑慧试用”"><img src="/post/b13a/4vs3.png" class="" title="上四层体现为端到端，下三层体现为点到点"><img src="/post/b13a/full_process.png" class="" title="数据链路层才有头尾，物理层传0和1"><ul><li><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4></li></ul><p>程序本身   </p><ul><li><h4 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h4></li></ul><p>1 格式变换 <p> 2 加密解密 <p> 3 压缩恢复</p><ul><li><h4 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h4></li></ul><p>向表示层&#x2F;用户进程建立连接<p><br>1 建立、管理、终止会话 <p> 2 使用校验点&#x2F;同步点恢复通信，实现同步(传输大文件)</p><ul><li><h4 id="传输层（传输单位：报文段-用户数据报）"><a href="#传输层（传输单位：报文段-用户数据报）" class="headerlink" title="传输层（传输单位：报文段&#x2F;用户数据报）"></a>传输层（传输单位：报文段&#x2F;用户数据报）</h4></li></ul><p>1 可靠传输（大文件，需要校验）&#x2F;不可靠传输（小文件）<p><br>2 差错控制<p><br>3 流量控制（防止缓存过多）<p><br>4 复用（多个应用层同时使用下面的运输层服务）分用（运输层把信息分别交给对应进程）</p><ul><li><h4 id="网络层-数据报-n-分组，分开方便传输"><a href="#网络层-数据报-n-分组，分开方便传输" class="headerlink" title="网络层(数据报 &#x3D; n * 分组，分开方便传输)"></a>网络层(数据报 &#x3D; n * 分组，分开方便传输)</h4></li></ul><p>1 路由选择-&gt;最佳路径<p><br>2 差错控制<p><br>3 流量控制<p><br>4 拥塞控制</p><ul><li><h4 id="数据链路层-帧-n-数据报"><a href="#数据链路层-帧-n-数据报" class="headerlink" title="数据链路层 帧 = n * 数据报"></a>数据链路层 <code>帧 = n * 数据报</code></h4></li></ul><p>1 成帧 <p>2 差错控制<p> 3 流量控制 <p>4 访问接入控制（广播式，控制信道访问） </p><ul><li><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4></li></ul><p>1 定义解口特性  <p>2 单工（固定角色）；半双工（同时只有一个人发送信息，但是都有机会发送、接收）；双工（同时发送、接收） <p>3 定义传输速率 <p> 4 比特同步（时钟控制） <p> 5 比特编码（电压范围） </p><h2 id="TCP-IP参考模型（4层）"><a href="#TCP-IP参考模型（4层）" class="headerlink" title="TCP&#x2F;IP参考模型（4层）"></a>TCP&#x2F;IP参考模型（4层）</h2><p>事实标准（先有协议才有模型）</p><img src="/post/b13a/ISO_vs_TCP_IP.png" class="" title="对比"><img src="/post/b13a/ISO_vs_TCP_IP(2).png" class="" title="对比(2)"><p>为什么说TCP&#x2F;IP将IP作为重要层次，所以在网络层指由无连接的模式？</p><details>  <summary>ChatGPT的回答</summary>TCP/IP是一种通信协议族，由两个主要的协议组成：TCP（传输控制协议）和IP（网际协议）。它们在计算机网络中扮演了重要的角色。<br>TCP/IP将IP作为重要的层次，因为IP负责在网络层提供数据包的路由和传递。网络层是TCP/IP协议栈中的第三层，其主要功能是处理数据包的转发和路由，以确保数据能够在不同网络之间传输。<br>IP协议采用无连接的传输模式，也称为"无状态"传输。这意味着在传输数据之前，IP不会建立任何持久的连接或会话状态。每个数据包在传输时都是独立的实体，它们被独立地处理和转发，与之前或之后的数据包没有直接关联。<br>IP作为无连接协议的主要优点是简单和灵活。由于每个数据包都是独立的，网络中的路由器可以更容易地处理和转发它们。这种无连接的特性使得IP协议适用于许多不同类型的网络，并且使得网络扩展更加容易，因为新的设备可以很容易地加入网络而不需要修改网络的整体结构。<br>然而，无连接的传输模式也带来了一些问题。由于IP不维护连接状态，因此无法保证数据包的顺序到达目的地，也不能保证数据包的可靠传输。为了解决这些问题，TCP协议在IP之上提供了可靠的、面向连接的数据传输，从而构成了TCP/IP协议栈的两个主要部分。<br>总的来说，TCP/IP将IP作为重要的层次，并在网络层采用无连接的传输模式，这使得网络可以更加灵活和简单，但也需要上层协议如TCP来提供可靠性和有序性。</details><h3 id="5层结构"><a href="#5层结构" class="headerlink" title="5层结构"></a>5层结构</h3><img src="/post/b13a/5%E5%B1%82%E7%BB%93%E6%9E%84.png" class="" title="结构"><img src="/post/b13a/5%E5%B1%82%E8%A7%A3%E5%B0%81%E8%A3%85.png" class="" title="步骤"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/post/b13a/%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%84%91%E5%9B%BE%E6%80%BB%E7%BB%93.png" class="" title="summary"><p>第一章用了两天时间刷完了，感觉有点喘不上气，不过情绪还算平稳。用这个速度下去岂不是特么半个月学完了。。。所以还是要刷题巩固，要不然全是骗自己呢。加油😄。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大一暑假小结</title>
      <link href="/post/97185e65.html"/>
      <url>/post/97185e65.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="暑假过半小总结"><a href="#暑假过半小总结" class="headerlink" title="暑假过半小总结"></a>暑假过半小总结</h1><h2 id="学习永无止境"><a href="#学习永无止境" class="headerlink" title="学习永无止境"></a>学习永无止境</h2><p>自从放假以来，已经有一个多月了。这三十多天里，虽然不能说收获颇多，起码能称得上充实有料。都快上大二的人了，才开始重视保研竞赛加分，只能说侧面反映这个大一摆得真得舒服。不论怎样，起码已经开始动起来了：</p><h3 id="算法：从入门到入士"><a href="#算法：从入门到入士" class="headerlink" title="算法：从入门到入士(?"></a>算法：从入门到入士(?</h3><p>学习了（观看，部分实现）左神的19节体系算法班的课程，课程时长共计40h，接触了包括但不限于复杂度、异或运算、归并排序、二叉树、递归与动态规划、KMP算法、bfprt算法等等知识概念，不过有很大程度<br>上都是看得很爽而自己不太想动手。这是一个需要耐心解决的毛病😄。主要还是要亲自下海感受一下这些算法的魅力之处，老是看别人玩怎么行，不手撕一下代码这个东西永远都是别人的。所以，从今天起，每一次的课程都要<br>以自己动手为最终目标，而不是以量为目标学习。不过量也不能太少，起码每天要接触些新的奇技淫巧，也要做到手不生疏就行。</p><h3 id="规划：任何时候都不迟！"><a href="#规划：任何时候都不迟！" class="headerlink" title="规划：任何时候都不迟！"></a>规划：任何时候都不迟！</h3><p>初步了解、规划大二的时间安排情况。<code>首先</code>要保证课内的课程分数可观，起码要能有一定的提升，主课不能落下，所以晚上千万要早一些睡。 <code>其次</code>，要及时关注教务处的通知，比如这一次的全国大学生数学竞赛就是因为我太专注于<br>（？还不是你好久没登教务处网）复习而没有关注到报名需求，导致最后失去这个绝佳的机会。又要等待一年才能有机会参加。 <code>最后</code>，要合理规划时间，腾出来的时间要么用来看专业书，要么用来看名校的网课，要么用来考研，要么用来提高课内的学分绩点课程，要么用来弄竞赛或者科研，要么用来跑实验室（如果有机会进实验室的话🤭）。总之，用来玩的时间可以说越来越少了，大学很短，且行且珍惜。</p><h3 id="走访：穿越到未来看我的样子"><a href="#走访：穿越到未来看我的样子" class="headerlink" title="走访：穿越到未来看我的样子"></a>走访：穿越到未来看我的样子</h3><p>这个暑假还<code>走访了oppo、百度、腾讯三家头部企业</code>，其中oppo是我校的学长学姐接待的，热情满满；百度是部门刚入职的学长接待的，很接地气；腾讯是位十分漂亮的小姐姐带我们走了全程，传授了很多面经。总的来说，虽然我还没有接触什么技术栈或者一些具体的工作流程，但是在像这些公司一样的一家<code>重视员工</code>的企业，我觉得<code>非常具有幸福感</code>~跟他们交流，不仅对自己的未来规划会更加清晰，还能收获一些分量十足的建议，这也是我非常想进实验室的原因。一定要努力呀！！</p><h3 id="自我反思：提醒自己入行的初衷"><a href="#自我反思：提醒自己入行的初衷" class="headerlink" title="自我反思：提醒自己入行的初衷"></a>自我反思：提醒自己入行的初衷</h3><p>其实我还是会时常问自己，为什么我要选择这个道路？思来想去，到最后答案都是想创造一个机器替代人工的社会，一个生产力爆棚的社会，一个精神层次能更高的社会。我小时候就有<code>危机感</code>，害怕人类被机器取代以后就难以掌控世界。其实这种担心客观来说是合理的，但是这不是抑制技术发展的理由。我相信在良好的环境（不论是监管环境，开源环境或者是某些方面的社会环境）下，机器一定能给人一种<code>类天堂</code>的感觉，只是这离我们还有一点点距离。在这个注定会深刻改变未来的时间点，踏足计算机科学真的是一件很酷的事情。</p><h2 id="给生活加点料"><a href="#给生活加点料" class="headerlink" title="给生活加点料"></a>给生活加点料</h2><h3 id="足球：最大的爱好"><a href="#足球：最大的爱好" class="headerlink" title="足球：最大的爱好"></a>足球：最大的爱好</h3><p>一回来就有同学约球，一踢就是到晚上十点，结果回家的路上去地铁站，跟同学聊天tmd走偏了好几公里，好在赶上末班车顺利到家😕，要不真的半夜还在马路上，谁看了都担心这帅小伙被拐走了U•ェ•*U</p><h3 id="电影：八角笼中"><a href="#电影：八角笼中" class="headerlink" title="电影：八角笼中"></a>电影：八角笼中</h3><p>高中同学约我去看，虽然套路确实太tm土了，不过里面的一些人物还是挺引人深思的：穷困家庭的孩子，小时候就跟着大人一起打劫，就算是后来被培养成了拳击能手，<code>一旦失去了一个长辈的在场管教</code>，他就像一块永磁铁，被打劫这一块吸铁石牢牢地吸走，重新开启旧事业。老鼠儿子会打洞，<code>人的家庭环境对其一生的影响是不可估量的</code>。你说这个拳击教练他有错吗？<code>必然有</code>，因为他插手了这些孩子们的童年和青春，所以他必须要为他们的成人做好准备。既然他是唯一一个孩子们亲近的大人，除了教他们打拳击挣钱（不寒掺！），更要给他们一些<code>心理的建设</code>，这才是支撑他们克服原生家庭的<code>唯一法宝</code>。他们重拾旧业，就是因为他们骨子里还是那个穷小子，那个没有一技傍身，即使他们已经在拳击行业有一些傲人的成就。我记得到最后他们也没有真正进学校上过一次学，意味着他们的学历将是“无”，虽然我也不搞学历崇拜，但是现实中如果有这么一批孩子，是多么可悲、可怜。所以，其实这整个社会都付有一定的连带责任，但是如果这个社会并不是唯学历论，我相信这群年轻的孩子肯定可以通过自己的双手打拼出来，<code>带着他们的姐姐来城市看一看世间的繁华</code>，而不是窝在阴暗的床上编手工品。</p><h3 id="探访母校：对人以诚，对事以精"><a href="#探访母校：对人以诚，对事以精" class="headerlink" title="探访母校：对人以诚，对事以精"></a>探访母校：对人以诚，对事以精</h3><p>看完电影，同学说想参观下我的初中母校，于是步行10min到达校门口。跟警卫处说明来意，他们非常乐意地开了门。我们绕了整个学校一圈，还特地去九六班看了看，怀念那时的卷王姿态啊~中午放学、下午放学我总是全班最后一个走，真想不懂那时为啥这么卷，也许就是那时的我给我现在的条件吧。应了多年前的那句网络名言“未来的你，会感谢现在努力的自己”。实话实说，在城市中心夜晚的母校，就是望着窗外睡一觉都会感觉很舒服。我可能是个灯光控吧😄。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实这个暑假还有一些小故事，比如，pubg<code>出了金</code>（烟枪，虽然没啥用，不过这是第二次免费出金了嘻嘻）；还有<code>分到了想去的人工智能专业</code>等等，不一而足。一句话概括，那就是：<br><code>这个暑假，为我这平淡无奇的学生生涯添上了丰富的色彩，纵使未来充满挑战，但我一定能看到希望，把握机遇。</code></p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> 日记/规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 活着，就要有人样 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序之反思</title>
      <link href="/post/673e5681.html"/>
      <url>/post/673e5681.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>  众所周知，快速排序是一个复杂度较为低的排序，平均时间复杂度约n*log(n)，今天，我尝试对快速排序的本质做一些理解和复习。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span>  a[<span class="number">101</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort1</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j, t, temp;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        temp = a[left];<span class="comment">//temp中存的就是基准数</span></span><br><span class="line">        i = left;<span class="comment">//左边界</span></span><br><span class="line">        j = right;<span class="comment">//右边界</span></span><br><span class="line">        <span class="keyword">while</span>(i != j)&#123;<span class="comment">//当左右边界相等时，说明已经遍历完毕</span></span><br><span class="line">                <span class="keyword">while</span>(a[j] &gt;= temp &amp;&amp; i &lt; j)<span class="comment">//从右往左找到第一个小于temp的数</span></span><br><span class="line">                        j--;<span class="comment">//j--</span></span><br><span class="line">                <span class="keyword">while</span>(a[i] &lt;= temp &amp;&amp; i &lt; j)<span class="comment">//从左往右找到第一个大于temp的数</span></span><br><span class="line">                        i++;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; j)&#123;<span class="comment">//为何是i&lt;j，因为i==j时，说明已经遍历完毕</span></span><br><span class="line">                        t = a[i];<span class="comment">//交换</span></span><br><span class="line">                        a[i] = a[j];</span><br><span class="line">                        a[j] = t;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[left] = a[i];</span><br><span class="line">        a[i] = temp;</span><br><span class="line">        <span class="built_in">quicksort1</span>(left, i - <span class="number">1</span>);<span class="comment">//</span></span><br><span class="line">        <span class="built_in">quicksort1</span>(i + <span class="number">1</span>, right);<span class="comment">//递归</span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>   这是一开始的想法。取最左边的元素为<code>基准点</code>，然后j先动，直到找到<code>小于基准点</code>的那个元素；接着动i，直到找到<code>大于基准点</code>的那个元素；交换j,i的元素；像这个步骤顺序执行，直到任何一刻，<code>i == j</code>，然后，交换i位置和<code>基准点</code>位置的元素。这样就能达到<code>基准点</code>左侧的数<code>小于基准点</code>，<code>基准点</code>左侧的数<code>大于基准点</code>。然后，再调用递归，分别将<code>基准点</code>左侧和右侧<code>修正</code>为面向<code>新基准点</code>的类排序状态，直到这个调用结束。说实话，这有一点像深度优先搜索的例子。<br>    但是，chatgpt告诉我，它有更好的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left];</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[i++] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[j--] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    <span class="built_in">quicksort</span>(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quicksort</span>(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这是gpt的思路：它一开始就不打算将arr[left]保留至原位置。当j移动到<code>小于基准点</code>的位置，原来i位置的数会被j位置的覆盖；然后i移动到<code>大于基准点</code>的位置，j位置的数于是被i位置的覆盖。如此循环，仅仅a[left]是没有<br>被放进数列的。最后当i和j相遇，不管前面是什么情况，这个相遇位置的数一定已经被移动到它应该去的地方，于是在此处写入a[left]。然后也是调用递归。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>   其实快速排序让我敬畏之许久，导致很长一段时间我都觉得这个排序很“迷”。为何？因为它的边界条件、特殊情况和执行顺序：</p><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p>   a[left]是最大的数，且整个数列是逆序的，不就会执行非常多次？<br>    确实，如果是逆序，那么是会执行n + (n-1) + (n-2) + … + 1 次，也就是冒泡排序的次数。</p><h3 id="特殊情况-执行顺序"><a href="#特殊情况-执行顺序" class="headerlink" title="特殊情况&#x2F;执行顺序"></a>特殊情况&#x2F;执行顺序</h3><p>   如果i从左至右能找到三个<code>大于基准点</code>的数，反之j从右至左能找到一个或者两个<code>小于基准点</code>的数，那么这个排序不就不成立了？这是我从一开始就很疑惑的点。不妨来举一个例子说清楚这个问题：<br><code>arr = &#123;5, 6, 7, 8, 2 , 1&#125;</code>这个数组执行代码（第一种解法）过程中，1 和 6 会被先定位，然后交换<code>arr = &#123;5, 1, 7, 8, 2 , 6&#125;</code>，接着是2，7，<code>arr = &#123;5, 1, 2, 8, 7, 6&#125;</code></p><p>接下来，就是这个排序的精华（起码我是这么认为的啦）了：永远先让j动——j移动到 “2” 的位置，与i重合。然后 5 和 2 交换，得到<code>arr = &#123;2, 1, 5, 8, 7, 6&#125;</code>，怎么样，不还是能跑嘛！</p><p>   <em><strong>其实，j 先动，就能保证j右边的全是比 j 要大的，这是最重要的一环。</strong></em></p><p>如果把 i 和 j 的移动顺序调换，上面的例子会变成<code>arr = &#123;8, 1, 2, 5, 7, 6&#125;</code>（ i 先到 8 的位置）。这样就不符合 5 左边的数都比 5 小的初衷了。因为，如果 i 先动，只能保证 i 左边的数会比 <code>基准点</code> 小，但是这个过程中一旦 i 和 j 碰面了，或者像这个例子，i右边且j左边没有小于<code>基准点</code>的数了，一定会让这个尴尬的位置非常棘手。<em><strong>究其根本的原因，<br>   就是我们规定的是左小右大的排列顺序：最后一个和a[left]交换的一定不能大于<code>基准点</code>。所以，当j先动，不可避免地遇上了i，此时的i是先前被交换过来的那个 <code>旧j</code>位置的<code>小于基准点</code>的数，当然不怕和a[left]交换位置；<br>   然而当i先动，若是不可避免地遇上了j，此时的j是先前被交换过来的那个 <code>旧i</code>位置的<code>大于基准点</code>的数，当然不能和a[left]交换位置，否则新的a[left]不就一定会&gt;<code>基准点</code>咯！</strong></em></p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>   那么，如果左小右大，应该j先动，是不是说左大右小，就是i先动？让我们看下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left];</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &lt;= pivot)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[i++] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &gt;= pivot)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[j--] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    <span class="built_in">quicksort</span>(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quicksort</span>(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这是gpt给的，当然经过验证是正确的代码。我们可以看到，用这种方式，我们确实可以做到左小右大。经过今天的分析，我们能得到一个结论：i和j的移动顺序和得到的数组的要求有密切的关系：要求 &#x3D;&#x3D; 左小右大？ j 先动 : 要求 &#x3D;&#x3D; 左大右小？ : i 先动 : 俺也不知道。<br>   （容我写个嵌套三目结束今天的战斗！）</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> c++ </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
