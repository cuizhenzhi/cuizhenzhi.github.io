<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快速排序之反思</title>
      <link href="/2023/08/02/2023-08-01-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/08/02/2023-08-01-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>  众所周知，快速排序是一个复杂度较为低的排序，平均时间复杂度约n*log(n)，今天，我尝试对快速排序的本质做一些理解和复习。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pointer1 = left, pointer2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> s = right - left + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>* help = <span class="keyword">new</span> <span class="type">int</span>[s];</span><br><span class="line">    <span class="type">int</span>* help2 = <span class="keyword">new</span> <span class="type">int</span>[s];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pointer1 &lt;= mid &amp;&amp; pointer2 &lt;= right) &#123;</span><br><span class="line">        help2[i++] = a[pointer1] &lt; a[pointer2] ? a[pointer1++] : a[pointer2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pointer1 &lt;= mid) &#123;</span><br><span class="line">        help2[i++] = a[pointer1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (pointer2 &lt;= right) &#123;</span><br><span class="line">        help2[i++] = a[pointer2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        a[left + i] = help2[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] help2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这是一开始的想法。取最左边的元素为<code>基准点</code>，然后j先动，直到找到<code>小于基准点</code>的那个元素；接着动i，直到找到<code>大于基准点</code>的那个元素；交换j,i的元素；像这个步骤顺序执行，直到任何一刻，<code>i == j</code>，然后，<br>交换i位置和<code>基准点</code>位置的元素。这样就能达到<code>基准点</code>左侧的数<code>小于基准点</code>，<code>基准点</code>左侧的数<code>大于基准点</code>。然后，再调用递归，分别将<code>基准点</code>左侧和右侧<code>修正</code>为面向<code>新基准点</code>的类排序<br>状态，直到这个调用结束。说实话，这有一点像深度优先搜索的例子。<br>    但是，chatgpt告诉我，它有更好的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left];</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt;= pivot)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[i++] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[j--] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    <span class="built_in">quicksort</span>(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quicksort</span>(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这是gpt的思路：它一开始就不打算将arr[left]保留至原位置。当j移动到<code>小于基准点</code>的位置，原来i位置的数会被j位置的覆盖；然后i移动到<code>大于基准点</code>的位置，j位置的数于是被i位置的覆盖。如此循环，仅仅a[left]是没有<br>被放进数列的。最后当i和j相遇，不管前面是什么情况，这个相遇位置的数一定已经被移动到它应该去的地方，于是在此处写入a[left]。然后也是调用递归。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>   其实快速排序让我敬畏之许久，导致很长一段时间我都觉得这个排序很“迷”。为何？因为它的边界条件、特殊情况和执行顺序：</p><h3 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h3><p>   a[left]是最大的数，且整个数列是逆序的，不就会执行非常多次？<br>    确实，如果是逆序，那么是会执行n + (n-1) + (n-2) + … + 1 次，也就是冒泡排序的次数。</p><h3 id="特殊情况-执行顺序"><a href="#特殊情况-执行顺序" class="headerlink" title="特殊情况&#x2F;执行顺序"></a>特殊情况&#x2F;执行顺序</h3><p>   如果i从左至右能找到三个<code>大于基准点</code>的数，反之j从右至左能找到一个或者两个<code>小于基准点</code>的数，那么这个排序不就不成立了？这是我从一开始就很疑惑的点。不妨来举一个例子说清楚这个问题：<br><code>arr = &#123;5, 6, 7, 8, 2 , 1&#125;</code>这个数组执行代码（第一种解法）过程中，1 和 6 会被先定位，然后交换<code>arr = &#123;5, 1, 7, 8, 2 , 6&#125;</code>，接着是2，7，<code>arr = &#123;5, 1, 2, 8, 7, 6&#125;</code><br>接下来，就是这个排序的精华（起码我是这么认为的啦）了：永远先让j动——j移动到 “2” 的位置，与i重合。然后 5 和 2 交换，得到<code>arr = &#123;2, 1, 5, 8, 7, 6&#125;</code>，怎么样，不还是能跑嘛！<br>   其实，j 先动，就能保证j右边的全是比 j 要大的，这是最重要的一环。如果把 i 和 j 的移动顺序调换，上面的例子会变成<code>arr = &#123;8, 1, 2, 5, 7, 6&#125;</code>（ i 先到 8 的位置）。这样就不符合 5 左边的数都比 5 小的<br>   初衷了。因为，如果 i 先动，只能保证 i 左边的数会比 <code>基准点</code> 小，但是这个过程中一旦 i 和 j 碰面了，或者像这个例子，i右边且j左边没有小于<code>基准点</code>的数了，一定会让这个尴尬的位置非常棘手。<em><strong>究其根本的原因，<br>   就是我们规定的是左小右大的排列顺序：最后一个和a[left]交换的一定不能大于<code>基准点</code>。所以，当j先动，不可避免地遇上了i，此时的i是先前被交换过来的那个 <code>旧j</code>位置的<code>小于基准点</code>的数，当然不怕和a[left]交换位置；<br>   然而当i先动，若是不可避免地遇上了j，此时的j是先前被交换过来的那个 <code>旧i</code>位置的<code>大于基准点</code>的数，当然不能和a[left]交换位置，否则新的a[left]不就一定会&gt;<code>基准点</code>咯！</strong></em></p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>   那么，如果左小右大，应该j先动，是不是说左大右小，就是i先动？让我们看下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> pivot = arr[left];</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &lt;= pivot)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[i++] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &gt;= pivot)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            arr[j--] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = pivot;</span><br><span class="line">    <span class="built_in">quicksort</span>(arr, left, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quicksort</span>(arr, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   这是gpt给的，当然经过验证是正确的代码。我们可以看到，用这种方式，我们确实可以做到左小右大。经过今天的分析，我们能得到一个结论：i和j的移动顺序和得到的数组的要求有密切的关系：要求 &#x3D;&#x3D; 左小右大？ j 先动 : 要求 &#x3D;&#x3D; 左大右小？ : i 先动 : 俺也不知道。<br>   （容我写个嵌套三目结束今天的战斗！）</p>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>third passage</title>
      <link href="/2023/07/31/third-passage/"/>
      <url>/2023/07/31/third-passage/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#第三篇文章</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>c++usage</title>
      <link href="/2023/07/31/First-blog/"/>
      <url>/2023/07/31/First-blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>#日志<br>今天布置了网站封面，添加底部音乐元素， 增加留言板设置</p><hr><hr><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>代码测试：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>unbelievable </p><p>图片测试：</p><p><img src="http://mculover666.cn/blog/20191031/R4mWMXsrRKxu.png?imageslim"></p><p>引用测试：</p><blockquote><p>这是一条引用</p></blockquote><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>无序列表测试：</p><ul><li>哈哈</li><li>嘿嘿</li><li>吼吼</li></ul><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4>]]></content>
      
      
      <categories>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> java </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
